================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-28T18:33:19.831Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
core/
  config/
    app_config.dart
  errors/
    exceptions.dart
  network/
    api_client.dart
  providers/
    core_providers.dart
  storage/
    session_storage.dart
features/
  auth/
    data/
      session_manager.dart
    domain/
      user.dart
    presentation/
      providers/
        auth_provider.dart
  chat/
    data/
      chat_service.dart
    domain/
      models/
        entity.dart
        message.dart
    presentation/
      providers/
        chat_provider.dart
        entity_provider.dart
      chat_screen.dart
      splash_screen.dart
    widgets/
      entity/
        entity_card.dart
        entity_detail_view.dart
      chat_title_bar.dart
      message_bubble.dart
      message_list.dart
      search_input.dart
shared/
  widgets/
    app_button.dart
main.dart

================================================================
Repository Files
================================================================

================
File: main.dart
================
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'core/storage/session_storage.dart';
import 'core/network/api_client.dart';
import 'features/chat/presentation/chat_screen.dart';
import 'features/auth/presentation/providers/auth_provider.dart';
import 'features/chat/presentation/splash_screen.dart';
import 'core/providers/core_providers.dart';

void main() async {
  try {
    // Ensure Flutter bindings are initialized
    WidgetsFlutterBinding.ensureInitialized();

    // Initialize Hive
    await Hive.initFlutter();

    // Initialize session storage
    final sessionStorage = SessionStorage();
    await sessionStorage.init();

    // Initialize API client
    final apiClient = ApiClient();

    // Run app with providers
    runApp(
      ProviderScope(
        overrides: [
          // Override the API client provider with our initialized instance
          apiClientProvider.overrideWithValue(apiClient),
          // Override the session storage provider with our initialized instance
          sessionStorageProvider.overrideWithValue(sessionStorage),
        ],
        child: const FlywallApp(),
      ),
    );
  } catch (e, stackTrace) {
    debugPrint('Error during app initialization: $e');
    debugPrint('Stack trace: $stackTrace');

    // Show error UI if initialization fails
    runApp(
      MaterialApp(
        home: Scaffold(
          body: Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    color: Colors.red,
                    size: 48,
                  ),
                  const SizedBox(height: 16),
                  const Text(
                    'Failed to initialize app',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    e.toString(),
                    textAlign: TextAlign.center,
                    style: const TextStyle(color: Colors.red),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class FlywallApp extends ConsumerWidget {
  const FlywallApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);

    return MaterialApp(
      title: 'Flywall',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: authState.status == AuthStatus.authenticated
          ? const ChatScreen()
          : const SplashScreen(),
    );
  }
}

================
File: core/config/app_config.dart
================
// lib/core/config/app_config.dart
class AppConfig {
  static const bool useLocalHost = false; // Set to false for production

  // API Configuration
  static String get baseUrl => useLocalHost
      ? 'http://10.0.2.2:8000' // Android emulator localhost
      : 'https://fapi.nyn.sh'; // Production API

  static const String apiVersion = 'v1';
  static String get apiPath => '/api/$apiVersion';

  // API Endpoints
  static String get authEndpoint => '$baseUrl/auth';
  static String get tokenEndpoint => '$authEndpoint/token';
  static String get registerEndpoint => '$authEndpoint/register';
  static String get userEndpoint => '$authEndpoint/users/me';
  static String get sidekickEndpoint => '$baseUrl$apiPath/sidekick';

  // WebSocket Configuration
  static String get wsUrl =>
      useLocalHost ? 'ws://10.0.2.2:8000/ws' : 'wss://fapi.nyn.sh/ws';

  // Storage keys
  static const String sessionBoxName = 'flywall_session';
  static const String userSecretKey = 'user_secret';
  static const String threadIdKey = 'thread_id';

  // Timeouts
  static const Duration connectionTimeout = Duration(seconds: 30);
  static const Duration receiveTimeout = Duration(seconds: 30);

  // Error Messages
  static const String networkErrorMessage =
      'Unable to connect to the server. Please check your internet connection.';
  static const String serverErrorMessage =
      'Something went wrong on our end. Please try again later.';
  static const String authErrorMessage =
      'Authentication failed. Please try again.';
}

================
File: core/errors/exceptions.dart
================
abstract class AppException implements Exception {
  const AppException(this.message);
  final String message;
}

class AuthException extends AppException {
  const AuthException(super.message);
}

class NetworkException extends AppException {
  const NetworkException(super.message);
}

class StorageException extends AppException {
  const StorageException(super.message);
}

================
File: core/network/api_client.dart
================
// lib/core/network/api_client.dart
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../errors/exceptions.dart';

class ApiClient {
  late final Dio _dio;

  ApiClient() {
    _dio = Dio(BaseOptions(
      connectTimeout: AppConfig.connectionTimeout,
      receiveTimeout: AppConfig.receiveTimeout,
      validateStatus: (status) => status != null && status < 500,
    ));

    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        return handler.next(options);
      },
      onResponse: (response, handler) {
        return handler.next(response);
      },
      onError: (DioException e, handler) async {
        if (e.type == DioExceptionType.connectionTimeout ||
            e.type == DioExceptionType.receiveTimeout) {
          if (e.requestOptions.extra['retryCount'] == null ||
              e.requestOptions.extra['retryCount'] < 3) {
            final options = e.requestOptions;
            options.extra['retryCount'] =
                (options.extra['retryCount'] ?? 0) + 1;
            return handler.resolve(await _dio.fetch(options));
          }
        }
        return handler.next(e);
      },
    ));
  }

  Future<Response<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.get<T>(
        path,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.post<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> put<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.put<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> delete<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.delete<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  AppException _handleError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return const NetworkException(AppConfig.networkErrorMessage);

      case DioExceptionType.badResponse:
        if (e.response?.statusCode == 401) {
          return const AuthException(AppConfig.authErrorMessage);
        }
        return NetworkException(
            e.response?.statusMessage ?? AppConfig.serverErrorMessage);

      default:
        return const NetworkException(AppConfig.networkErrorMessage);
    }
  }

  void setAuthToken(String token) {
    _dio.options.headers['Authorization'] = 'Bearer $token';
  }

  void clearAuthToken() {
    _dio.options.headers.remove('Authorization');
  }
}

================
File: core/providers/core_providers.dart
================
// lib/core/providers/core_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../network/api_client.dart';
import '../storage/session_storage.dart';

/// Core API client provider
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient());

/// Session storage provider
final sessionStorageProvider =
    Provider<SessionStorage>((ref) => SessionStorage());

================
File: core/storage/session_storage.dart
================
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../config/app_config.dart';

class SessionStorage {
  late Box _box;

  static const String userNameKey = 'user_name';

  Future<void> init() async {
    _box = await Hive.openBox(AppConfig.sessionBoxName);
    debugPrint('Session storage initialized: ${hasSession()}');
  }

  // User name methods
  Future<void> saveUserName(String name) async {
    await _box.put(userNameKey, name);
    debugPrint('User name saved: $name');
  }

  Future<String?> getUserName() async {
    final name = _box.get(userNameKey) as String?;
    debugPrint('Retrieved user name: $name');
    return name;
  }

  // User secret methods
  Future<void> saveUserSecret(String secret) async {
    await _box.put(AppConfig.userSecretKey, secret);
    debugPrint('User secret saved: $secret');
  }

  Future<String?> getUserSecret() async {
    final secret = _box.get(AppConfig.userSecretKey) as String?;
    debugPrint('Retrieved user secret: $secret');
    return secret;
  }

  // Thread ID methods
  Future<void> saveThreadId(String? threadId) async {
    if (threadId != null) {
      await _box.put(AppConfig.threadIdKey, threadId);
      debugPrint('Thread ID saved: $threadId');
    } else {
      await _box.delete(AppConfig.threadIdKey);
      debugPrint('Thread ID cleared');
    }
  }

  Future<String?> getThreadId() async {
    final threadId = _box.get(AppConfig.threadIdKey) as String?;
    debugPrint('Retrieved thread ID: $threadId');
    return threadId;
  }

  // Session management methods
  Future<void> clearSession() async {
    await _box.clear(); // This will clear everything including the user name
    debugPrint('Session cleared');
  }

  bool hasSession() {
    final hasSecret = _box.containsKey(AppConfig.userSecretKey);
    debugPrint('Has session: $hasSecret');
    return hasSecret;
  }

  // Helper method to check if we have a stored name
  bool hasUserName() {
    final hasName = _box.containsKey(userNameKey);
    debugPrint('Has user name: $hasName');
    return hasName;
  }
}

================
File: shared/widgets/app_button.dart
================
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isOutlined;

  const AppButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isOutlined = false,
  });

  @override
  Widget build(BuildContext context) {
    final style = isOutlined
        ? OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          )
        : ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          );

    final child = isLoading
        ? const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          )
        : Text(text);

    return isOutlined
        ? OutlinedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          )
        : ElevatedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          );
  }
}

================
File: features/auth/domain/user.dart
================
class User {
  final String id;
  final String screenName;
  final String? accessToken;

  const User({
    required this.id,
    required this.screenName,
    this.accessToken,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      screenName: json['screen_name'] as String,
      accessToken: json['access_token'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'screen_name': screenName,
      if (accessToken != null) 'access_token': accessToken,
    };
  }

  User copyWith({
    String? screenName,
  }) {
    return User(
      id: id,
      screenName: screenName ?? this.screenName,
      accessToken: accessToken,
    );
  }
}

================
File: features/auth/data/session_manager.dart
================
// lib/features/auth/data/session_manager.dart
import 'package:flutter/foundation.dart';
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../../../core/storage/session_storage.dart';
import '../../../core/errors/exceptions.dart';
import '../domain/user.dart';
import 'package:dio/dio.dart';

class SessionManager {
  final ApiClient _apiClient;
  final SessionStorage _storage;
  User? _currentUser;

  SessionManager(this._apiClient, this._storage);

  User? get currentUser => _currentUser;

  Future<bool> login(String userSecret) async {
    try {
      debugPrint('Attempting login with secret: $userSecret');

      // Using form data instead of JSON for the token endpoint
      final response = await _apiClient.post(
        AppConfig.tokenEndpoint,
        data: {'user_secret': userSecret},
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
        ),
      );

      debugPrint('Login response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;

        // Save the access token and user secret
        await _storage.saveUserSecret(userSecret);

        // Store current user with token
        _currentUser = User(
          id: data['user_id'] ?? '',
          screenName: data['screen_name'] ?? '',
          accessToken: data['access_token'],
        );

        // Set the auth token for future requests
        _apiClient.setAuthToken(_currentUser!.accessToken!);

        // Fetch additional user info
        await _fetchUserInfo();

        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<User> register(String screenName) async {
    try {
      debugPrint('Attempting registration for: $screenName');

      final response = await _apiClient.post(
        AppConfig.registerEndpoint,
        data: {'screen_name': screenName},
      );

      debugPrint('Registration response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        final userSecret = data['user_secret'];

        // Immediately login with the received user_secret
        final loginSuccess = await login(userSecret);
        if (!loginSuccess) {
          throw const AuthException('Login failed after registration');
        }

        return _currentUser!;
      }
      throw const AuthException('Registration failed');
    } catch (e) {
      debugPrint('Registration error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<void> _fetchUserInfo() async {
    try {
      final response = await _apiClient.get(AppConfig.userEndpoint);
      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        _currentUser = _currentUser?.copyWith(
          screenName: data['screen_name'],
          // Add other fields as needed
        );
      }
    } catch (e) {
      debugPrint('Error fetching user info: $e');
    }
  }

  Future<void> logout() async {
    await _storage.clearSession();
    _currentUser = null;
    _apiClient.clearAuthToken();
  }

  Future<bool> restoreSession() async {
    final userSecret = await _storage.getUserSecret();
    debugPrint('Restoring session with secret: $userSecret');
    if (userSecret != null) {
      return login(userSecret);
    }
    return false;
  }
}

================
File: features/chat/data/chat_service.dart
================
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../domain/models/message.dart';

class ChatService {
  final ApiClient _apiClient;

  ChatService(this._apiClient);

  Future<Message> sendMessage(String input, {String? threadId}) async {
    try {
      final response = await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/ask',
        data: {
          'user_input': input,
          if (threadId != null) 'thread_id': threadId,
        },
      );

      return Message.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Message>> getThread(String threadId) async {
    try {
      final response = await _apiClient.get(
        '${AppConfig.sidekickEndpoint}/conversation/$threadId',
      );

      return (response.data as List)
          .map((json) => Message.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      rethrow;
    }
  }
}

================
File: features/chat/presentation/chat_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../widgets/search_input.dart';
import '../widgets/message_list.dart';
import '../widgets/entity/entity_detail_view.dart';
import '../widgets/chat_title_bar.dart';
import 'providers/chat_provider.dart';
import 'providers/entity_provider.dart';
import '../../../core/providers/core_providers.dart';

class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({super.key});

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  final scrollController = ScrollController();
  String? _userName;
  String? _userSecret;

  @override
  void initState() {
    super.initState();
    _loadUserData();
  }

  Future<void> _loadUserData() async {
    final storage = ref.read(sessionStorageProvider);
    final userName = await storage.getUserName();
    final userSecret = await storage.getUserSecret();
    if (mounted) {
      setState(() {
        _userName = userName;
        _userSecret = userSecret;
      });
    }
  }

  void _scrollToBottom() {
    if (scrollController.hasClients) {
      scrollController.animateTo(
        scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  Future<void> _copyUserSecret() async {
    if (_userSecret != null) {
      await Clipboard.setData(ClipboardData(text: _userSecret!));
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('User secret copied to clipboard'),
            behavior: SnackBarBehavior.floating,
            duration: Duration(seconds: 2),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatState = ref.watch(chatProvider);
    final selectedEntity = ref.watch(selectedEntityProvider);
    final hasMessages = chatState.messages.isNotEmpty;
    final isThreadComplete =
        chatState.messages.lastOrNull?.isThreadComplete ?? false;

    // Listen for changes and scroll to bottom when new messages arrive
    ref.listen<ChatState>(chatProvider, (previous, next) {
      if (previous?.messages.length != next.messages.length) {
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
      }

      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(next.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    });

    return Scaffold(
      backgroundColor: Colors.grey[50],
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                ChatTitleBar(
                  userSecret: _userSecret,
                  onCopy: _copyUserSecret,
                ),
                if (hasMessages)
                  Expanded(
                    child: MessageList(
                      messages: chatState.messages,
                      scrollController: scrollController,
                      isThreadComplete: isThreadComplete,
                    ),
                  ),
                SearchInput(
                  onSubmitted: (input) {
                    if (input.trim().isNotEmpty) {
                      // Clear previous thread if completed
                      if (isThreadComplete) {
                        ref.read(chatProvider.notifier).clearThread();
                      }
                      ref.read(chatProvider.notifier).sendMessage(input);
                    }
                  },
                  enabled: !chatState.isLoading,
                  isThreadActive: hasMessages,
                  userName: _userName,
                ),
              ],
            ),
            if (chatState.isLoading)
              Positioned(
                bottom: 90, // Position loader just above the search box
                right: 32,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(20),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 4,
                      ),
                    ],
                  ),
                  child: const CircularProgressIndicator(),
                ),
              ),
            if (selectedEntity != null)
              Positioned.fill(
                child: GestureDetector(
                  onTap: () =>
                      ref.read(selectedEntityProvider.notifier).state = null,
                  child: Container(
                    color: Colors.black54,
                    alignment: Alignment.center,
                    child: EntityDetailView(
                      entity: selectedEntity,
                      onClose: () => ref
                          .read(selectedEntityProvider.notifier)
                          .state = null,
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    scrollController.dispose();
    super.dispose();
  }
}

================
File: features/chat/presentation/splash_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../auth/presentation/providers/auth_provider.dart';
import 'chat_screen.dart';
import '../../../../core/providers/core_providers.dart';

class NameInputDialog extends StatefulWidget {
  const NameInputDialog({super.key});

  @override
  State<NameInputDialog> createState() => _NameInputDialogState();
}

class _NameInputDialogState extends State<NameInputDialog> {
  final _controller = TextEditingController();
  String? _error;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              'Welcome to Flywall!',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Please enter your name to continue',
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 24),
            TextField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: 'Your name',
                errorText: _error,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              textCapitalization: TextCapitalization.words,
              autofocus: true,
              onSubmitted: (value) => _submit(context),
            ),
            const SizedBox(height: 24),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => _submit(context),
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text('Continue'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _submit(BuildContext context) {
    final name = _controller.text.trim();
    if (name.isEmpty) {
      setState(() => _error = 'Please enter your name');
      return;
    }
    if (name.length < 2) {
      setState(() => _error = 'Name must be at least 2 characters');
      return;
    }
    Navigator.of(context).pop(name);
  }
}

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  String? _userName;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeApp();
    });
  }

  Future<void> _initializeApp() async {
    final storage = ref.read(sessionStorageProvider);
    _userName = await storage.getUserName();

    if (!mounted) return;
    setState(() => _isLoading = false);

    if (storage.hasSession()) {
      await _handleExistingSession();
    } else {
      await _handleNewUser();
    }
  }

  Future<void> _handleExistingSession() async {
    final authNotifier = ref.read(authProvider.notifier);
    final storage = ref.read(sessionStorageProvider);

    try {
      final hasSession = await authNotifier.checkAuth();
      if (!mounted) return;

      if (!hasSession) {
        await storage.clearSession();
        await _handleNewUser();
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.toString())),
      );
    }
  }

  Future<void> _handleNewUser() async {
    if (!mounted) return;

    final name = await showDialog<String>(
      context: context,
      barrierDismissible: false,
      builder: (context) => const NameInputDialog(),
    );

    if (!mounted) return;

    if (name != null) {
      final storage = ref.read(sessionStorageProvider);
      await storage.saveUserName(name);
      setState(() => _userName = name);

      final authNotifier = ref.read(authProvider.notifier);
      await authNotifier.registerAndLogin(name);
    }
  }

  @override
  Widget build(BuildContext context) {
    ref.listen(authProvider, (previous, next) {
      if (!mounted) return;

      if (next.status == AuthStatus.authenticated) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ChatScreen()),
        );
      } else if (next.status == AuthStatus.error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error ?? 'An error occurred')),
        );
      }
    });

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const FlutterLogo(size: 100),
            const SizedBox(height: 24),
            const Text(
              'Flywall',
              style: TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
              ),
            ),
            if (_userName != null) ...[
              const SizedBox(height: 16),
              Text(
                'Welcome back, $_userName!',
                style: const TextStyle(
                  fontSize: 18,
                  color: Colors.grey,
                ),
              ),
            ],
            const SizedBox(height: 48),
            if (_isLoading) const CircularProgressIndicator(),
          ],
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/chat_title_bar.dart
================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class ChatTitleBar extends StatelessWidget {
  final String? userSecret;
  final VoidCallback? onCopy;

  const ChatTitleBar({
    super.key,
    this.userSecret,
    this.onCopy,
  });

  Future<void> _copyToClipboard(BuildContext context) async {
    if (userSecret != null) {
      await Clipboard.setData(ClipboardData(text: userSecret!));
      if (onCopy != null) onCopy!();

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('User secret copied to clipboard'),
            duration: Duration(seconds: 2),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          Text(
            'User Secret:',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: Colors.grey[700],
            ),
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              userSecret ?? 'Not available',
              style: TextStyle(
                color: Colors.grey[600],
                fontFamily: 'monospace',
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (userSecret != null)
            IconButton(
              icon: const Icon(Icons.copy, size: 20),
              onPressed: () => _copyToClipboard(context),
              tooltip: 'Copy user secret',
              splashRadius: 20,
            ),
        ],
      ),
    );
  }
}

================
File: features/chat/widgets/message_bubble.dart
================
// lib/features/chat/widgets/message_bubble.dart
import 'package:flutter/material.dart';
import '../domain/models/message.dart';

class MessageBubble extends StatelessWidget {
  final Message message;

  const MessageBubble({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: message.type == MessageType.system
            ? Colors.grey.shade200
            : Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            message.content,
            style: Theme.of(context).textTheme.bodyLarge,
          ),
          if (message.tokenUsage != null) ...[
            const SizedBox(height: 8),
            Text(
              'Tokens: ${message.tokenUsage!['total_tokens'] ?? 0} '
                  '(prompt: ${message.tokenUsage!['prompt_tokens'] ?? 0}, '
                  'completion: ${message.tokenUsage!['completion_tokens'] ?? 0})',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Colors.grey,
              ),
            ),
          ],
        ],
      ),
    );
  }
}

================
File: features/chat/widgets/message_list.dart
================
import 'package:flutter/material.dart';
import '../presentation/providers/chat_provider.dart';

class MessageList extends StatelessWidget {
  final List<ChatMessage> messages;
  final ScrollController scrollController;
  final bool isThreadComplete;

  const MessageList({
    super.key,
    required this.messages,
    required this.scrollController,
    required this.isThreadComplete,
  });

  @override
  Widget build(BuildContext context) {
    // Reverse the messages list to show newest at the bottom
    final reversedMessages = messages.reversed.toList();

    return ListView.builder(
      controller: scrollController,
      reverse: true, // This makes the list build from bottom to top
      padding: const EdgeInsets.only(
        left: 8,
        right: 8,
        top: 20,
        bottom: 8,
      ),
      itemCount: reversedMessages.length + (isThreadComplete ? 1 : 0),
      itemBuilder: (context, index) {
        if (index == 0 && isThreadComplete) {
          return Padding(
            padding: const EdgeInsets.only(bottom: 16.0),
            child: Container(
              padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
              decoration: BoxDecoration(
                color: Colors.blue.withOpacity(0.1),
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: Colors.blue.withOpacity(0.2),
                ),
              ),
              child: Column(
                children: [
                  Text(
                    'Thread complete',
                    style: TextStyle(
                      color: Colors.blue[700],
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Ask a question to start a new thread',
                    style: TextStyle(
                      color: Colors.blue[600],
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
          );
        }

        final message = reversedMessages[index - (isThreadComplete ? 1 : 0)];
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 4.0),
          child: Align(
            alignment: message.isUserMessage
                ? Alignment.centerRight
                : Alignment.centerLeft,
            child: Container(
              constraints: BoxConstraints(
                maxWidth: MediaQuery.of(context).size.width * 0.75,
              ),
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: message.isUserMessage ? Colors.blue[100] : Colors.white,
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.05),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Text(
                message.content,
                style: TextStyle(
                  color: message.isUserMessage ? Colors.black87 : Colors.black,
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

================
File: features/chat/widgets/search_input.dart
================
import 'package:flutter/material.dart';

class SearchInput extends StatefulWidget {
  final Function(String) onSubmitted;
  final bool enabled;
  final bool isThreadActive;
  final String? userName;

  const SearchInput({
    super.key,
    required this.onSubmitted,
    this.enabled = true,
    this.isThreadActive = false,
    this.userName,
  });

  @override
  State<SearchInput> createState() => _SearchInputState();
}

class _SearchInputState extends State<SearchInput>
    with SingleTickerProviderStateMixin {
  final TextEditingController _controller = TextEditingController();
  bool _hasText = false;
  late final AnimationController _animationController;
  late final Animation<double> _slideAnimation;

  @override
  void initState() {
    super.initState();
    _controller.addListener(_updateHasText);
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _slideAnimation = Tween<double>(
      begin: 0,
      end: 1,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    ));
  }

  @override
  void didUpdateWidget(SearchInput oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isThreadActive != oldWidget.isThreadActive) {
      if (widget.isThreadActive) {
        _animationController.forward();
      } else {
        _animationController.reverse();
      }
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_updateHasText);
    _controller.dispose();
    _animationController.dispose();
    super.dispose();
  }

  void _updateHasText() {
    setState(() {
      _hasText = _controller.text.trim().isNotEmpty;
    });
  }

  void _handleSubmit(String value) {
    if (value.trim().isNotEmpty && widget.enabled) {
      widget.onSubmitted(value);
      _controller.clear();
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (!widget.isThreadActive) ...[
              const SizedBox(height: 80),
              ShaderMask(
                shaderCallback: (bounds) => const LinearGradient(
                  colors: [Colors.blue, Colors.purple],
                ).createShader(bounds),
                child: const Text(
                  'Flywall',
                  style: TextStyle(
                    fontSize: 64,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              if (widget.userName != null) ...[
                const SizedBox(height: 24),
                Text(
                  'Hello, ${widget.userName}',
                  style: TextStyle(
                    fontSize: 18,
                    color: Colors.grey[600],
                  ),
                ),
              ],
              const SizedBox(height: 48),
            ],
            Container(
              margin: EdgeInsets.symmetric(
                horizontal: widget.isThreadActive ? 16 : 32,
                vertical: 16,
              ),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(30),
                color: Colors.white,
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _controller,
                      enabled: widget.enabled,
                      decoration: InputDecoration(
                        hintText: widget.enabled
                            ? 'Ask anything...'
                            : 'Please wait...',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(30),
                          borderSide: BorderSide.none,
                        ),
                        filled: true,
                        fillColor:
                            widget.enabled ? Colors.white : Colors.grey[100],
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 24,
                          vertical: 16,
                        ),
                      ),
                      onSubmitted: _handleSubmit,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.send),
                    onPressed: _hasText && widget.enabled
                        ? () => _handleSubmit(_controller.text)
                        : null,
                    color:
                        _hasText && widget.enabled ? Colors.blue : Colors.grey,
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }
}

================
File: features/chat/domain/models/entity.dart
================
enum EntityType { task, note, person, topic }

class Entity {
  final String id;
  final EntityType type;
  final String title;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final List<String> tags;

  const Entity({
    required this.id,
    required this.type,
    required this.title,
    required this.data,
    required this.timestamp,
    this.tags = const [],
  });

  factory Entity.fromJson(Map<String, dynamic> json) {
    try {
      return Entity(
        id: json['id']?.toString() ??
            DateTime.now().microsecondsSinceEpoch.toString(),
        type: EntityType.values.firstWhere(
          (e) =>
              e.name.toLowerCase() == (json['type'] as String?)?.toLowerCase(),
          orElse: () => EntityType.task,
        ),
        title: json['title']?.toString() ?? 'Untitled',
        data: _sanitizeData(json['data']),
        timestamp: _parseDateTime(json['timestamp']) ?? DateTime.now(),
        tags: _parseTags(json['tags']),
      );
    } catch (e, stackTrace) {
      print('Error parsing Entity from JSON: $e\n$stackTrace');
      // Return a default entity if parsing fails
      return Entity(
        id: DateTime.now().microsecondsSinceEpoch.toString(),
        type: EntityType.task,
        title: 'Error: Invalid Entity',
        data: {'error': e.toString()},
        timestamp: DateTime.now(),
        tags: const [],
      );
    }
  }

  Map<String, dynamic> toJson() {
    try {
      return {
        'id': id,
        'type': type.name,
        'title': title,
        'data': data,
        'timestamp': timestamp.toIso8601String(),
        'tags': tags,
      };
    } catch (e) {
      print('Error converting Entity to JSON: $e');
      return {
        'id': id,
        'type': type.name,
        'title': title,
        'data': {},
        'timestamp': DateTime.now().toIso8601String(),
        'tags': [],
      };
    }
  }

  // Helper method to safely parse DateTime
  static DateTime? _parseDateTime(dynamic value) {
    if (value == null) return null;
    if (value is DateTime) return value;
    if (value is String) {
      try {
        return DateTime.parse(value);
      } catch (_) {
        try {
          // Try parsing timestamp as milliseconds since epoch
          return DateTime.fromMillisecondsSinceEpoch(int.parse(value));
        } catch (_) {
          return null;
        }
      }
    }
    if (value is int) {
      try {
        return DateTime.fromMillisecondsSinceEpoch(value);
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  // Helper method to safely parse tags
  static List<String> _parseTags(dynamic value) {
    if (value == null) return [];
    if (value is List) {
      return value
          .where((element) => element != null)
          .map((element) => element.toString())
          .toList();
    }
    if (value is String) {
      return [value];
    }
    return [];
  }

  // Helper method to sanitize data map
  static Map<String, dynamic> _sanitizeData(dynamic value) {
    if (value == null) return {};
    if (value is Map<String, dynamic>) {
      return Map<String, dynamic>.from(value.map((key, value) {
        // Convert null values to empty strings or appropriate defaults
        if (value == null) return MapEntry(key, '');
        if (value is Map) {
          return MapEntry(key, _sanitizeData(value));
        }
        if (value is List) {
          return MapEntry(key, _sanitizeList(value));
        }
        return MapEntry(key, value);
      }));
    }
    return {};
  }

  // Helper method to sanitize lists in data
  static List<dynamic> _sanitizeList(List list) {
    return list.map((item) {
      if (item == null) return '';
      if (item is Map) return _sanitizeData(item);
      if (item is List) return _sanitizeList(item);
      return item;
    }).toList();
  }

  // Convenience method to get a safely typed value from data
  T? getValue<T>(String key) {
    final value = data[key];
    if (value is T) return value;
    return null;
  }

  // Helper method to get a string value with a default
  String getStringValue(String key, {String defaultValue = ''}) {
    final value = data[key];
    if (value == null) return defaultValue;
    return value.toString();
  }

  // Helper method to check if a key exists and has a non-null value
  bool hasValue(String key) {
    return data.containsKey(key) && data[key] != null;
  }

  @override
  String toString() {
    return 'Entity{id: $id, type: $type, title: $title, timestamp: $timestamp, tags: $tags}';
  }

  // Create a copy of the entity with updated fields
  Entity copyWith({
    String? id,
    EntityType? type,
    String? title,
    Map<String, dynamic>? data,
    DateTime? timestamp,
    List<String>? tags,
  }) {
    return Entity(
      id: id ?? this.id,
      type: type ?? this.type,
      title: title ?? this.title,
      data: data ?? Map<String, dynamic>.from(this.data),
      timestamp: timestamp ?? this.timestamp,
      tags: tags ?? List<String>.from(this.tags),
    );
  }

  // Helper to create an empty entity of a specific type
  factory Entity.empty(EntityType type) {
    return Entity(
      id: DateTime.now().microsecondsSinceEpoch.toString(),
      type: type,
      title: 'New ${type.name}',
      data: {},
      timestamp: DateTime.now(),
      tags: [],
    );
  }
}

================
File: features/chat/domain/models/message.dart
================
// lib/features/chat/domain/models/message.dart

import 'entity.dart';

enum MessageType { text, entity, system }

class Message {
  final String id;
  final String content;
  final MessageType type;
  final List<Entity> entities;
  final DateTime timestamp;
  final Map<String, dynamic>? tokenUsage;
  final String? threadId;
  final bool isThreadComplete;
  final Map<String, int> updatedEntities;
  final String? newPrompt;

  const Message({
    required this.id,
    required this.content,
    this.type = MessageType.text,
    this.entities = const [],
    required this.timestamp,
    this.tokenUsage,
    this.threadId,
    this.isThreadComplete = false,
    this.updatedEntities = const {},
    this.newPrompt,
  });

  factory Message.fromJson(Map<String, dynamic> json) {
    try {
      // Generate a unique message ID if none provided
      final id = json['id']?.toString() ??
          DateTime.now().microsecondsSinceEpoch.toString();

      // Use 'response' field as content, falling back to 'content' if not present
      final content =
          json['response']?.toString() ?? json['content']?.toString() ?? '';

      // Parse entities from the new structure
      final entities = <Entity>[];
      if (json['entities'] is Map<String, dynamic>) {
        final entitiesMap = json['entities'] as Map<String, dynamic>;

        // Process tasks
        if (entitiesMap['tasks'] is List) {
          for (final task in entitiesMap['tasks']) {
            try {
              if (task is Map<String, dynamic>) {
                entities.add(Entity(
                  id: task['task_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.task,
                  title: task['title']?.toString() ?? 'Untitled Task',
                  data: Map<String, dynamic>.from(task),
                  timestamp:
                      DateTime.tryParse(task['created_at']?.toString() ?? '') ??
                          DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing task: $e');
            }
          }
        }

        // Process notes
        if (entitiesMap['notes'] is List) {
          for (final note in entitiesMap['notes']) {
            try {
              if (note is Map<String, dynamic>) {
                entities.add(Entity(
                  id: note['note_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.note,
                  title: note['content']?.toString() ?? 'Untitled Note',
                  data: Map<String, dynamic>.from(note),
                  timestamp:
                      DateTime.tryParse(note['created_at']?.toString() ?? '') ??
                          DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing note: $e');
            }
          }
        }

        // Process people
        if (entitiesMap['people'] is List) {
          for (final person in entitiesMap['people']) {
            try {
              if (person is Map<String, dynamic>) {
                entities.add(Entity(
                  id: person['person_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.person,
                  title: person['name']?.toString() ??
                      person['screen_name']?.toString() ??
                      'Unnamed Person',
                  data: Map<String, dynamic>.from(person),
                  timestamp: DateTime.tryParse(
                          person['created_at']?.toString() ?? '') ??
                      DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing person: $e');
            }
          }
        }

        // Process topics
        if (entitiesMap['topics'] is List) {
          for (final topic in entitiesMap['topics']) {
            try {
              if (topic is Map<String, dynamic>) {
                entities.add(Entity(
                  id: topic['topic_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.topic,
                  title: topic['name']?.toString() ?? 'Untitled Topic',
                  data: Map<String, dynamic>.from(topic),
                  timestamp: DateTime.tryParse(
                          topic['created_at']?.toString() ?? '') ??
                      DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing topic: $e');
            }
          }
        }
      }

      // Parse token usage safely
      Map<String, dynamic>? tokenUsage;
      if (json['token_usage'] is Map) {
        tokenUsage = Map<String, dynamic>.from(json['token_usage'] as Map);
      }

      // Parse updated entities safely
      final updatedEntities = <String, int>{};
      if (json['updated_entities'] is Map) {
        final updateMap = json['updated_entities'] as Map;
        for (final entry in updateMap.entries) {
          try {
            updatedEntities[entry.key.toString()] =
                int.tryParse(entry.value.toString()) ?? 0;
          } catch (e) {
            print('Error parsing updated entity count: $e');
          }
        }
      }

      return Message(
        id: id,
        content: content,
        type: MessageType.values.firstWhere(
          (t) => t.name == (json['type'] as String?)?.toLowerCase(),
          orElse: () => MessageType.text,
        ),
        entities: entities,
        timestamp: DateTime.tryParse(json['timestamp']?.toString() ?? '') ??
            DateTime.now(),
        tokenUsage: tokenUsage,
        threadId: json['thread_id']?.toString(),
        isThreadComplete: json['is_thread_complete'] as bool? ?? false,
        updatedEntities: updatedEntities,
        newPrompt: json['new_prompt']?.toString(),
      );
    } catch (e, stackTrace) {
      print('Error parsing Message: $e');
      print('Stack trace: $stackTrace');

      // Return a default error message if parsing fails
      return Message(
        id: DateTime.now().microsecondsSinceEpoch.toString(),
        content: 'Error parsing message: $e',
        type: MessageType.system,
        timestamp: DateTime.now(),
        isThreadComplete: false,
      );
    }
  }

  Map<String, dynamic> toJson() {
    try {
      return {
        'id': id,
        'content': content,
        'type': type.name,
        'entities': entities.map((e) => e.toJson()).toList(),
        'timestamp': timestamp.toIso8601String(),
        if (tokenUsage != null) 'token_usage': tokenUsage,
        if (threadId != null) 'thread_id': threadId,
        'is_thread_complete': isThreadComplete,
        'updated_entities': updatedEntities,
        if (newPrompt != null) 'new_prompt': newPrompt,
      };
    } catch (e) {
      print('Error converting Message to JSON: $e');
      return {
        'id': id,
        'content': content,
        'type': type.name,
        'timestamp': timestamp.toIso8601String(),
        'is_thread_complete': isThreadComplete,
      };
    }
  }

  Message copyWith({
    String? id,
    String? content,
    MessageType? type,
    List<Entity>? entities,
    DateTime? timestamp,
    Map<String, dynamic>? tokenUsage,
    String? threadId,
    bool? isThreadComplete,
    Map<String, int>? updatedEntities,
    String? newPrompt,
  }) {
    return Message(
      id: id ?? this.id,
      content: content ?? this.content,
      type: type ?? this.type,
      entities: entities ?? this.entities,
      timestamp: timestamp ?? this.timestamp,
      tokenUsage: tokenUsage ?? this.tokenUsage,
      threadId: threadId ?? this.threadId,
      isThreadComplete: isThreadComplete ?? this.isThreadComplete,
      updatedEntities: updatedEntities ?? this.updatedEntities,
      newPrompt: newPrompt ?? this.newPrompt,
    );
  }
}

================
File: features/auth/presentation/providers/auth_provider.dart
================
// lib/features/auth/presentation/providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/session_manager.dart';
import '../../domain/user.dart';
import '../../../../core/providers/core_providers.dart';

// Session manager provider
final sessionManagerProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  final storage = ref.watch(sessionStorageProvider);
  return SessionManager(apiClient, storage);
});

// Auth state
enum AuthStatus { initial, loading, authenticated, error }

class AuthState {
  final AuthStatus status;
  final User? user;
  final String? error;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.error,
  });

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      error: error,
    );
  }
}

class AuthNotifier extends StateNotifier<AuthState> {
  final SessionManager _sessionManager;

  AuthNotifier(this._sessionManager) : super(const AuthState());

  Future<bool> checkAuth() async {
    try {
      state = state.copyWith(status: AuthStatus.loading);
      final success = await _sessionManager.restoreSession();

      if (success) {
        state = state.copyWith(
          status: AuthStatus.authenticated,
          user: _sessionManager.currentUser,
        );
      } else {
        state = state.copyWith(status: AuthStatus.initial);
      }

      return success;
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
      return false;
    }
  }

  Future<void> registerAndLogin(String name) async {
    try {
      state = state.copyWith(status: AuthStatus.loading);
      final user = await _sessionManager.register(name);
      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
      );
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
    }
  }

  Future<void> logout() async {
    await _sessionManager.logout();
    state = const AuthState(status: AuthStatus.initial);
  }
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final sessionManager = ref.watch(sessionManagerProvider);
  return AuthNotifier(sessionManager);
});

================
File: features/chat/presentation/providers/chat_provider.dart
================
// lib/features/chat/presentation/providers/chat_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/chat_service.dart';
import '../../domain/models/message.dart';
import '../../../../core/providers/core_providers.dart';

// Export ChatState for use in other files
export '../../domain/models/message.dart';

// Service provider
final chatServiceProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ChatService(apiClient);
});

class ChatMessage {
  final String content;
  final bool isUserMessage;
  final bool isThreadComplete;
  final DateTime timestamp;
  final String? threadId;
  final bool isError;

  ChatMessage({
    required this.content,
    required this.isUserMessage,
    this.isThreadComplete = false,
    DateTime? timestamp,
    this.threadId,
    this.isError = false,
  }) : timestamp = timestamp ?? DateTime.now();
}

class ChatState {
  final List<ChatMessage> messages;
  final bool isLoading;
  final String? error;
  final String? currentThreadId;
  final Message? messageBeingRetried;

  const ChatState({
    this.messages = const [],
    this.isLoading = false,
    this.error,
    this.currentThreadId,
    this.messageBeingRetried,
  });

  ChatState copyWith({
    List<ChatMessage>? messages,
    bool? isLoading,
    String? error,
    String? currentThreadId,
    Message? messageBeingRetried,
  }) {
    return ChatState(
      messages: messages ?? this.messages,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      currentThreadId: currentThreadId ?? this.currentThreadId,
      messageBeingRetried: messageBeingRetried ?? this.messageBeingRetried,
    );
  }
}

class ChatNotifier extends StateNotifier<ChatState> {
  final ChatService _chatService;

  ChatNotifier(this._chatService) : super(const ChatState());

  Future<void> sendMessage(String message) async {
    // Add user message immediately
    state = state.copyWith(
      messages: [
        ...state.messages,
        ChatMessage(content: message, isUserMessage: true),
      ],
      isLoading: true,
      error: null,
    );

    try {
      final response = await _chatService.sendMessage(
        message,
        threadId: state.currentThreadId,
      );

      state = state.copyWith(
        messages: [
          ...state.messages,
          ChatMessage(
            content: response.content,
            isUserMessage: false,
            threadId: response.threadId,
            isThreadComplete: response.isThreadComplete,
          ),
        ],
        currentThreadId: response.threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
        messages: [
          ...state.messages,
          ChatMessage(
            content: 'Error: ${e.toString()}',
            isUserMessage: false,
            isError: true,
          ),
        ],
      );
    }
  }

  Future<void> retryMessage(Message message) async {
    state = state.copyWith(messageBeingRetried: message);
    await sendMessage(message.content);
    state = state.copyWith(messageBeingRetried: null);
  }

  Future<void> loadThread(String threadId) async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      final messages = await _chatService.getThread(threadId);

      // Convert Message objects to ChatMessage objects
      final chatMessages = messages
          .map((msg) => ChatMessage(
                content: msg.content,
                isUserMessage: msg.type == MessageType.text,
                threadId: msg.threadId,
                timestamp: msg.timestamp,
                isThreadComplete: msg.isThreadComplete,
              ))
          .toList();

      state = state.copyWith(
        messages: chatMessages,
        currentThreadId: threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void clearThread() {
    state = const ChatState();
  }
}

// Export the provider for use in other files
final chatProvider = StateNotifierProvider<ChatNotifier, ChatState>((ref) {
  final chatService = ref.watch(chatServiceProvider);
  return ChatNotifier(chatService);
});

================
File: features/chat/presentation/providers/entity_provider.dart
================
// lib/features/chat/presentation/providers/entity_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/entity.dart';
import '../../../../core/providers/core_providers.dart';
import '../../../../core/config/app_config.dart';
import '../../../../core/network/api_client.dart';

// State provider for tracking the currently selected entity
final selectedEntityProvider = StateProvider<Entity?>((ref) => null);

// Action states
final entityActionsLoadingProvider = StateProvider<bool>((ref) => false);
final entityActionsErrorProvider = StateProvider<String?>((ref) => null);

// Entity actions provider with API client
final entityActionsProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return EntityActions(apiClient);
});

class EntityActions {
  final ApiClient _apiClient;

  EntityActions(this._apiClient);

  Future<void> completeTask(String taskId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/tasks/$taskId/complete',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> editNote(String noteId, String content) async {
    try {
      await _apiClient.put(
        '${AppConfig.sidekickEndpoint}/notes/$noteId',
        data: {'content': content},
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> addPersonToTeam(String personId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/people/$personId/team',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> createTaskFromTopic(String topicId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/topics/$topicId/task',
      );
    } catch (e) {
      rethrow;
    }
  }
}

================
File: features/chat/widgets/entity/entity_card.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/entity.dart';
import 'entity_detail_view.dart';

class EntityCard extends ConsumerWidget {
  final Entity entity;

  const EntityCard({
    super.key,
    required this.entity,
  });

  Color _getColorForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Colors.blue;
      case EntityType.note:
        return Colors.green;
      case EntityType.person:
        return Colors.purple;
      case EntityType.topic:
        return Colors.orange;
    }
  }

  String _getPreviewText(Entity entity) {
    switch (entity.type) {
      case EntityType.task:
        final dueDate = entity.data['due_date'];
        final status = entity.data['status'] ?? 'New';
        return [
          'Status: $status',
          if (dueDate != null) 'Due: $dueDate',
          _getRelatedEntitiesText(entity),
        ].where((text) => text.isNotEmpty).join('\n');

      case EntityType.note:
        return [
          entity.data['content']?.toString() ?? '',
          _getRelatedEntitiesText(entity),
        ].where((text) => text.isNotEmpty).join('\n');

      case EntityType.person:
        return [
          if (entity.data['role'] != null) 'Role: ${entity.data['role']}',
          if (entity.data['email'] != null) 'Email: ${entity.data['email']}',
          _getRelatedEntitiesText(entity),
        ].where((text) => text.isNotEmpty).join('\n');

      case EntityType.topic:
        return [
          entity.data['description']?.toString() ?? '',
          _getRelatedEntitiesText(entity),
        ].where((text) => text.isNotEmpty).join('\n');
    }
  }

  String _getRelatedEntitiesText(Entity entity) {
    final relatedEntities = <String>[];

    if (entity.data['related_people']?.isNotEmpty == true) {
      relatedEntities.add('${entity.data['related_people'].length} people');
    }
    if (entity.data['related_tasks']?.isNotEmpty == true) {
      relatedEntities.add('${entity.data['related_tasks'].length} tasks');
    }
    if (entity.data['related_topics']?.isNotEmpty == true) {
      relatedEntities.add('${entity.data['related_topics'].length} topics');
    }

    return relatedEntities.isEmpty
        ? ''
        : 'Related: ${relatedEntities.join(', ')}';
  }

  List<String> _getTags(Entity entity) {
    final tags = <String>[];

    switch (entity.type) {
      case EntityType.task:
        if (entity.data['status'] != null) {
          tags.add(entity.data['status']);
        }
        if (entity.data['priority'] != null) {
          tags.add(entity.data['priority']);
        }
        break;

      case EntityType.note:
        if (entity.data['categories'] is List) {
          tags.addAll(
              (entity.data['categories'] as List).map((e) => e.toString()));
        }
        break;

      case EntityType.person:
        if (entity.data['role'] != null) {
          tags.add(entity.data['role']);
        }
        if (entity.data['team'] != null) {
          tags.add(entity.data['team']);
        }
        break;

      case EntityType.topic:
        if (entity.data['keywords'] is List) {
          tags.addAll(
              (entity.data['keywords'] as List).map((e) => e.toString()));
        }
        break;
    }

    return tags;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final tags = _getTags(entity);

    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: () => showDialog(
          context: context,
          builder: (context) => EntityDetailView(
            entity: entity,
            onClose: () => Navigator.of(context).pop(),
          ),
        ),
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.all(16),
          width: 300, // Increased width for better content display
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  Text(
                    'Created: ${_formatDate(entity.timestamp)}',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Colors.grey,
                        ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Text(
                entity.title,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 8),
              Text(
                _getPreviewText(entity),
                style: Theme.of(context).textTheme.bodySmall,
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),
              if (tags.isNotEmpty) ...[
                const SizedBox(height: 12),
                SizedBox(
                  height: 24,
                  child: ListView.separated(
                    scrollDirection: Axis.horizontal,
                    itemCount: tags.length,
                    separatorBuilder: (_, __) => const SizedBox(width: 4),
                    itemBuilder: (context, index) => Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: _getColorForType(entity.type).withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        tags[index],
                        style: TextStyle(
                          fontSize: 12,
                          color: _getColorForType(entity.type),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  IconData _getIconForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Icons.task_alt;
      case EntityType.note:
        return Icons.note;
      case EntityType.person:
        return Icons.person;
      case EntityType.topic:
        return Icons.topic;
    }
  }

  IconData _getQuickActionIcon(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Icons.check_circle_outline;
      case EntityType.note:
        return Icons.edit;
      case EntityType.person:
        return Icons.person_add;
      case EntityType.topic:
        return Icons.add_task;
    }
  }

  String _getQuickActionTooltip(EntityType type) {
    switch (type) {
      case EntityType.task:
        return 'Mark Complete';
      case EntityType.note:
        return 'Edit Note';
      case EntityType.person:
        return 'Add to Team';
      case EntityType.topic:
        return 'Create Task';
    }
  }

  String _formatDate(DateTime date) {
    return '${date.month}/${date.day}/${date.year}';
  }
}

================
File: features/chat/widgets/entity/entity_detail_view.dart
================
// lib/features/chat/widgets/entity/entity_detail_view.dart

import 'package:flutter/material.dart';
import '../../domain/models/entity.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../presentation/providers/entity_provider.dart';

class EntityDetailView extends ConsumerWidget {
  final Entity entity;
  final VoidCallback onClose;

  const EntityDetailView({
    super.key,
    required this.entity,
    required this.onClose,
  });

  Future<void> _handleAction(
      BuildContext context, WidgetRef ref, Function action) async {
    try {
      ref.read(entityActionsLoadingProvider.notifier).state = true;
      ref.read(entityActionsErrorProvider.notifier).state = null;

      await action();

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Action completed successfully')),
        );
        onClose();
      }
    } catch (e) {
      ref.read(entityActionsErrorProvider.notifier).state = e.toString();
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString()),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      ref.read(entityActionsLoadingProvider.notifier).state = false;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isLoading = ref.watch(entityActionsLoadingProvider);
    final error = ref.watch(entityActionsErrorProvider);
    final actions = ref.watch(entityActionsProvider);

    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        constraints: const BoxConstraints(maxWidth: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header remains the same...
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: _getColorForType(entity.type).withOpacity(0.1),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  if (isLoading)
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  else
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: onClose,
                      color: Colors.black54,
                    ),
                ],
              ),
            ),

            if (error != null)
              Container(
                padding: const EdgeInsets.all(8),
                color: Colors.red.shade50,
                child: Text(
                  error,
                  style: TextStyle(color: Colors.red.shade700),
                ),
              ),

            // Content section remains the same...
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    entity.title,
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 16),
                  _buildEntityContent(context),
                  const SizedBox(height: 16),
                  if (entity.tags.isNotEmpty) ...[
                    const Divider(),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: entity.tags
                          .map((tag) => Chip(
                                label: Text(tag),
                                backgroundColor: _getColorForType(entity.type)
                                    .withOpacity(0.1),
                                labelStyle: TextStyle(
                                    color: _getColorForType(entity.type)),
                              ))
                          .toList(),
                    ),
                  ],
                ],
              ),
            ),

            // Updated action buttons with loading state
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  // Add type-specific action buttons
                  ...switch (entity.type) {
                    EntityType.task => [
                        TextButton.icon(
                          icon: const Icon(Icons.check_circle_outline),
                          label: const Text('Mark Complete'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.completeTask(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.note => [
                        TextButton.icon(
                          icon: const Icon(Icons.edit),
                          label: const Text('Edit'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.editNote(entity.id,
                                        entity.data['content'] ?? ''),
                                  ),
                        ),
                      ],
                    EntityType.person => [
                        TextButton.icon(
                          icon: const Icon(Icons.person_add),
                          label: const Text('Add to Team'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.addPersonToTeam(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.topic => [
                        TextButton.icon(
                          icon: const Icon(Icons.add_task),
                          label: const Text('Create Task'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () =>
                                        actions.createTaskFromTopic(entity.id),
                                  ),
                        ),
                      ],
                  },
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Utility methods remain the same...
  Color _getColorForType(EntityType type) => switch (type) {
        EntityType.task => Colors.blue,
        EntityType.note => Colors.green,
        EntityType.person => Colors.purple,
        EntityType.topic => Colors.orange,
      };

  IconData _getIconForType(EntityType type) => switch (type) {
        EntityType.task => Icons.task_alt,
        EntityType.note => Icons.note,
        EntityType.person => Icons.person,
        EntityType.topic => Icons.topic,
      };

  // _buildEntityContent remains the same...
  Widget _buildEntityContent(BuildContext context) {
    switch (entity.type) {
      case EntityType.task:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Status: ${entity.data['status'] ?? 'New'}',
              style: Theme.of(context).textTheme.bodyLarge,
            ),
            if (entity.data['due_date'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Due: ${entity.data['due_date']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            const SizedBox(height: 16),
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        );

      case EntityType.note:
        return Text(
          entity.data['content'] ?? '',
          style: Theme.of(context).textTheme.bodyMedium,
        );

      case EntityType.person:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (entity.data['email'] != null)
              Text(
                'Email: ${entity.data['email']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            if (entity.data['role'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Role: ${entity.data['role']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            if (entity.data['notes'] != null) ...[
              const SizedBox(height: 16),
              Text(
                entity.data['notes'],
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ],
          ],
        );

      case EntityType.topic:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if ((entity.data['keywords'] as List?)?.isNotEmpty ?? false) ...[
              const SizedBox(height: 16),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: (entity.data['keywords'] as List)
                    .map((keyword) => Chip(
                          label: Text(keyword),
                          backgroundColor: Colors.grey.shade200,
                        ))
                    .toList(),
              ),
            ],
          ],
        );
    }
  }
}
