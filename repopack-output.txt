================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-24T05:23:42.110Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
core/
  config/
    app_config.dart
  errors/
    exceptions.dart
  storage/
    session_storage.dart
features/
  auth/
    data/
      session_manager.dart
    domain/
      user.dart
    presentation/
      providers/
        auth_provider.dart
  chat/
    data/
      chat_service.dart
    domain/
      models/
        entity.dart
        message.dart
    presentation/
      providers/
        chat_provider.dart
      chat_screen.dart
      splash_screen.dart
    widgets/
      entity_card.dart
      message_bubble.dart
      message_list.dart
      search_input.dart
shared/
  widgets/
    app_button.dart
main.dart

================================================================
Repository Files
================================================================

================
File: main.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'core/storage/session_storage.dart';
import 'features/chat/presentation/chat_screen.dart';
import 'features/auth/presentation/providers/auth_provider.dart';
import 'features/chat/presentation/splash_screen.dart';

void main() async {
  try {
    WidgetsFlutterBinding.ensureInitialized();
    await Hive.initFlutter();

    final sessionStorage = SessionStorage();
    await sessionStorage.init();

    runApp(
      ProviderScope(
        child: FlywallApp(),
      ),
    );
  } catch (e, stackTrace) {
    debugPrint('Error during app initialization: $e');
    debugPrint('Stack trace: $stackTrace');
  }
}

class FlywallApp extends ConsumerWidget {
  const FlywallApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);

    return MaterialApp(
      title: 'Flywall',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: authState.status == AuthStatus.authenticated
          ? const ChatScreen()
          : const SplashScreen(),
    );
  }
}

================
File: core/storage/session_storage.dart
================
import 'package:hive_flutter/hive_flutter.dart';
import '../config/app_config.dart';

class SessionStorage {
  late Box _box;

  Future<void> init() async {
    _box = await Hive.openBox(AppConfig.sessionBoxName);
  }

  Future<void> saveUserSecret(String secret) async {
    await _box.put(AppConfig.userSecretKey, secret);
  }

  Future<void> saveThreadId(String? threadId) async {
    if (threadId != null) {
      await _box.put(AppConfig.threadIdKey, threadId);
    } else {
      await _box.delete(AppConfig.threadIdKey);
    }
  }

  Future<String?> getUserSecret() async {
    return _box.get(AppConfig.userSecretKey);
  }

  Future<String?> getThreadId() async {
    return _box.get(AppConfig.threadIdKey);
  }

  Future<void> clearSession() async {
    await _box.clear();
  }

  bool hasSession() {
    return _box.containsKey(AppConfig.userSecretKey);
  }
}

================
File: core/errors/exceptions.dart
================
abstract class AppException implements Exception {
  const AppException(this.message);
  final String message;
}

class AuthException extends AppException {
  const AuthException(super.message);
}

class NetworkException extends AppException {
  const NetworkException(super.message);
}

class StorageException extends AppException {
  const StorageException(super.message);
}

================
File: core/config/app_config.dart
================
class AppConfig {
  static const String baseUrl =
      'http://10.0.2.2:8000'; // Update with your API URL
  static const String apiVersion = 'v1';
  static const String apiPath = '/api/$apiVersion';
  static const String wsUrl =
      'ws://10.0.2.2:8000/ws'; // Update with your WebSocket URL

  // Storage keys
  static const String sessionBoxName = 'session_box';
  static const String userSecretKey = 'user_secret';
  static const String threadIdKey = 'thread_id';
}

================
File: shared/widgets/app_button.dart
================
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isOutlined;

  const AppButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isOutlined = false,
  });

  @override
  Widget build(BuildContext context) {
    final style = isOutlined
        ? OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          )
        : ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          );

    final child = isLoading
        ? const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          )
        : Text(text);

    return isOutlined
        ? OutlinedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          )
        : ElevatedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          );
  }
}

================
File: features/auth/data/session_manager.dart
================
import 'package:dio/dio.dart';
import '../../../core/config/app_config.dart';
import '../../../core/storage/session_storage.dart';
import '../../../core/errors/exceptions.dart';
import '../domain/user.dart';

class SessionManager {
  final Dio _dio;
  final SessionStorage _storage;
  User? _currentUser;

  SessionManager(this._dio, this._storage);

  User? get currentUser => _currentUser;

  Future<bool> login(String userSecret) async {
    try {
      final response = await _dio.post(
        '${AppConfig.baseUrl}/auth/token',
        data: {'user_secret': userSecret},
      );

      if (response.statusCode == 200) {
        final data = response.data;
        await _storage.saveUserSecret(userSecret);
        _currentUser = User.fromJson(data);
        return true;
      }
      return false;
    } on DioException catch (e) {
      throw AuthException(e.message ?? 'Login failed');
    }
  }

  Future<User> register(String screenName) async {
    try {
      final response = await _dio.post(
        '${AppConfig.baseUrl}/auth/register',
        data: {'screen_name': screenName},
      );

      if (response.statusCode == 200) {
        final user = User.fromJson(response.data);
        await login(response.data['user_secret']);
        return user;
      }
      throw const AuthException('Registration failed');
    } on DioException catch (e) {
      throw AuthException(e.message ?? 'Registration failed');
    }
  }

  Future<void> logout() async {
    await _storage.clearSession();
    _currentUser = null;
  }

  Future<bool> restoreSession() async {
    final userSecret = await _storage.getUserSecret();
    if (userSecret != null) {
      return login(userSecret);
    }
    return false;
  }
}

================
File: features/auth/domain/user.dart
================
class User {
  final String id;
  final String screenName;
  final String? accessToken;

  const User({
    required this.id,
    required this.screenName,
    this.accessToken,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      screenName: json['screen_name'] as String,
      accessToken: json['access_token'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'screen_name': screenName,
      if (accessToken != null) 'access_token': accessToken,
    };
  }
}

================
File: features/chat/data/chat_service.dart
================
import 'package:dio/dio.dart';
import '../domain/models/message.dart';
import '../../../core/config/app_config.dart';

class ChatService {
  final Dio _dio;

  ChatService(this._dio);

  Future<Message> sendMessage(String input, {String? threadId}) async {
    try {
      final response = await _dio.post(
        '${AppConfig.apiPath}/sidekick/ask',
        data: {
          'user_input': input,
          if (threadId != null) 'thread_id': threadId,
        },
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to send message: ${response.statusCode}');
      }

      return Message.fromJson(response.data);
    } on DioException catch (e) {
      if (e.type == DioExceptionType.connectionTimeout) {
        throw Exception('Connection timeout. Please try again.');
      } else if (e.response?.statusCode == 401) {
        throw Exception('Session expired. Please login again.');
      }
      throw Exception(e.message ?? 'Failed to send message');
    } catch (e) {
      throw Exception('An unexpected error occurred');
    }
  }

  Future<List<Message>> getThread(String threadId) async {
    try {
      final response = await _dio.get(
        '${AppConfig.apiPath}/sidekick/conversation/$threadId',
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to get thread: ${response.statusCode}');
      }

      return (response.data as List)
          .map((json) => Message.fromJson(json as Map<String, dynamic>))
          .toList();
    } on DioException catch (e) {
      if (e.type == DioExceptionType.connectionTimeout) {
        throw Exception('Connection timeout. Please try again.');
      } else if (e.response?.statusCode == 401) {
        throw Exception('Session expired. Please login again.');
      }
      throw Exception(e.message ?? 'Failed to get thread');
    } catch (e) {
      throw Exception('An unexpected error occurred');
    }
  }
}

================
File: features/chat/presentation/chat_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../widgets/search_input.dart';
import '../widgets/message_list.dart';
import 'providers/chat_provider.dart';

class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({super.key});

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  final scrollController = ScrollController();

  void _scrollToBottom() {
    if (scrollController.hasClients) {
      scrollController.animateTo(
        scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatState = ref.watch(chatProvider);

    // Listen for changes and scroll to bottom when new messages arrive
    ref.listen<ChatState>(chatProvider, (previous, next) {
      if (previous?.messages.length != next.messages.length) {
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
      }

      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(next.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    });

    return Scaffold(
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: SearchInput(
                onSubmitted: (input) {
                  if (input.trim().isNotEmpty) {
                    ref.read(chatProvider.notifier).sendMessage(input);
                  }
                },
                enabled: !chatState.isLoading,
              ),
            ),
            Expanded(
              child: Stack(
                children: [
                  MessageList(
                    messages: chatState.messages,
                    scrollController: scrollController,
                  ),
                  if (chatState.isLoading)
                    const Positioned(
                      top: 16,
                      right: 16,
                      child: CircularProgressIndicator(),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    scrollController.dispose();
    super.dispose();
  }
}

================
File: features/chat/presentation/splash_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../auth/presentation/providers/auth_provider.dart';
import 'chat_screen.dart';

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _handleAuth();
  }

  Future<void> _handleAuth() async {
    final authNotifier = ref.read(authProvider.notifier);

    // Try to restore session first
    final hasSession = await authNotifier.checkAuth();
    if (!mounted) return;

    if (!hasSession) {
      // If no session, register new user
      await authNotifier.registerAndLogin();
    }
  }

  @override
  Widget build(BuildContext context) {
    ref.listen(authProvider, (previous, next) {
      if (next.status == AuthStatus.authenticated) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ChatScreen()),
        );
      } else if (next.status == AuthStatus.error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error ?? 'An error occurred')),
        );
      }
    });

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const FlutterLogo(size: 100), // Replace with your app logo
            const SizedBox(height: 24),
            const Text(
              'Flywall',
              style: TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 48),
            const CircularProgressIndicator(),
          ],
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/entity_card.dart
================
// chat/widgets/entity_card.dart
import 'package:flutter/material.dart';
import '../domain/models/entity.dart';

class EntityCard extends StatelessWidget {
  final Entity entity;

  const EntityCard({
    super.key,
    required this.entity,
  });

  Color _getColorForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Colors.blue;
      case EntityType.note:
        return Colors.green;
      case EntityType.person:
        return Colors.purple;
      case EntityType.topic:
        return Colors.orange;
    }
  }

  IconData _getIconForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Icons.task_alt;
      case EntityType.note:
        return Icons.note;
      case EntityType.person:
        return Icons.person;
      case EntityType.topic:
        return Icons.topic;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: () {
          // TODO: Handle entity tap
        },
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.all(16),
          width: 200, // Fixed width for consistent layout
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                entity.title,
                style: Theme.of(context).textTheme.titleMedium,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),
              Text(
                // Show a preview of the data or description
                entity.data['description']?.toString() ?? '',
                style: Theme.of(context).textTheme.bodySmall,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/message_bubble.dart
================
// chat/widgets/message_bubble.dart
import 'package:flutter/material.dart';
import '../domain/models/message.dart';

class MessageBubble extends StatelessWidget {
  final Message message;

  const MessageBubble({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: message.type == MessageType.system
            ? Colors.grey.shade200
            : Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            message.content,
            style: Theme.of(context).textTheme.bodyLarge,
          ),
          if (message.tokenUsage != null) ...[
            const SizedBox(height: 8),
            Text(
              'Tokens: ${message.tokenUsage!["total"]}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Colors.grey,
                  ),
            ),
          ],
        ],
      ),
    );
  }
}

================
File: features/chat/widgets/message_list.dart
================
// chat/widgets/message_list.dart
import 'package:flutter/material.dart';
import '../domain/models/message.dart';
import 'message_bubble.dart';
import 'entity_card.dart';

class MessageList extends StatelessWidget {
  final List<Message> messages;
  final ScrollController scrollController;

  const MessageList({
    super.key,
    required this.messages,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: scrollController,
      padding: const EdgeInsets.all(16),
      itemCount: messages.length,
      itemBuilder: (context, index) {
        final message = messages[index];

        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            MessageBubble(message: message),
            if (message.entities.isNotEmpty) ...[
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: message.entities
                    .map((entity) => EntityCard(entity: entity))
                    .toList(),
              ),
            ],
            const SizedBox(height: 16),
          ],
        );
      },
    );
  }
}

================
File: features/chat/widgets/search_input.dart
================
import 'package:flutter/material.dart';

// chat/widgets/search_input.dart
class SearchInput extends StatefulWidget {
  final Function(String) onSubmitted;
  final bool enabled;

  const SearchInput({
    super.key,
    required this.onSubmitted,
    this.enabled = true,
  });

  @override
  State<SearchInput> createState() => _SearchInputState();
}

class _SearchInputState extends State<SearchInput> {
  final controller = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(24),
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: controller,
        enabled: widget.enabled,
        decoration: InputDecoration(
          hintText: widget.enabled ? 'Type something...' : 'Please wait...',
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(24),
            borderSide: BorderSide.none,
          ),
          filled: true,
          fillColor: widget.enabled ? Colors.white : Colors.grey[100],
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 20,
            vertical: 16,
          ),
          prefixIcon: const Icon(Icons.search),
          suffixIcon: widget.enabled && controller.text.isNotEmpty
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () => controller.clear(),
                )
              : null,
        ),
        onSubmitted: (value) {
          if (value.trim().isNotEmpty && widget.enabled) {
            widget.onSubmitted(value);
            controller.clear();
          }
        },
      ),
    );
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }
}

================
File: features/auth/presentation/providers/auth_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import '../../data/session_manager.dart';
import '../../domain/user.dart';
import '../../../../core/storage/session_storage.dart';

// Core providers
final dioProvider = Provider((ref) => Dio());
final sessionStorageProvider = Provider((ref) => SessionStorage());
final sessionManagerProvider = Provider((ref) {
  final dio = ref.watch(dioProvider);
  final storage = ref.watch(sessionStorageProvider);
  return SessionManager(dio, storage);
});

// Auth state
enum AuthStatus { initial, loading, authenticated, error }

class AuthState {
  final AuthStatus status;
  final User? user;
  final String? error;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.error,
  });

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      error: error,
    );
  }
}

class AuthNotifier extends StateNotifier<AuthState> {
  final SessionManager _sessionManager;

  AuthNotifier(this._sessionManager) : super(const AuthState());

  Future<bool> checkAuth() async {
    try {
      state = state.copyWith(status: AuthStatus.loading);
      final success = await _sessionManager.restoreSession();
      if (success) {
        state = state.copyWith(
          status: AuthStatus.authenticated,
          user: _sessionManager.currentUser,
        );
      }
      return success;
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
      return false;
    }
  }

  Future<void> registerAndLogin() async {
    try {
      state = state.copyWith(status: AuthStatus.loading);

      // Generate a random screen name (or handle it as per your requirement)
      final screenName = 'user_${DateTime.now().millisecondsSinceEpoch}';

      // Register new user
      final user = await _sessionManager.register(screenName);

      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
      );
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
    }
  }

  Future<void> logout() async {
    await _sessionManager.logout();
    state = const AuthState(status: AuthStatus.initial);
  }
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final sessionManager = ref.watch(sessionManagerProvider);
  return AuthNotifier(sessionManager);
});

================
File: features/chat/presentation/providers/chat_provider.dart
================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/chat_service.dart';
import '../../domain/models/message.dart';
import '../../../auth/presentation/providers/auth_provider.dart';

// Service provider
final chatServiceProvider = Provider((ref) {
  final dio = ref.watch(dioProvider);
  return ChatService(dio);
});

// Chat state
class ChatState {
  final List<Message> messages;
  final bool isLoading;
  final String? error;
  final String? currentThreadId;
  final Message? messageBeingRetried;

  const ChatState({
    this.messages = const [],
    this.isLoading = false,
    this.error,
    this.currentThreadId,
    this.messageBeingRetried,
  });

  ChatState copyWith({
    List<Message>? messages,
    bool? isLoading,
    String? error,
    String? currentThreadId,
    Message? messageBeingRetried,
  }) {
    return ChatState(
      messages: messages ?? this.messages,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      currentThreadId: currentThreadId ?? this.currentThreadId,
      messageBeingRetried: messageBeingRetried,
    );
  }
}

class ChatNotifier extends StateNotifier<ChatState> {
  final ChatService _chatService;

  ChatNotifier(this._chatService) : super(const ChatState());

  Future<void> sendMessage(String input) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final message = await _chatService.sendMessage(
        input,
        threadId: state.currentThreadId,
      );

      state = state.copyWith(
        messages: [...state.messages, message],
        currentThreadId: message.threadId,
        isLoading: false,
      );

      // Get thread completion status from message
      final isThreadComplete =
          message.tokenUsage?['is_thread_complete'] as bool? ?? false;
      if (isThreadComplete) {
        await Future.delayed(
            const Duration(seconds: 2)); // Give user time to read
        clearThread();
      }
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  Future<void> retryMessage(Message message) async {
    state = state.copyWith(messageBeingRetried: message);
    await sendMessage(message.content);
    state = state.copyWith(messageBeingRetried: null);
  }

  Future<void> loadThread(String threadId) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final messages = await _chatService.getThread(threadId);

      state = state.copyWith(
        messages: messages,
        currentThreadId: threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void clearThread() {
    state = const ChatState();
  }
}

final chatProvider = StateNotifierProvider<ChatNotifier, ChatState>((ref) {
  final chatService = ref.watch(chatServiceProvider);
  return ChatNotifier(chatService);
});

================
File: features/chat/domain/models/entity.dart
================
enum EntityType { task, note, person, topic }

class Entity {
  final String id;
  final EntityType type;
  final String title;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final List<String> tags;

  const Entity({
    required this.id,
    required this.type,
    required this.title,
    required this.data,
    required this.timestamp,
    this.tags = const [],
  });

  factory Entity.fromJson(Map<String, dynamic> json) {
    return Entity(
      id: json['id'] as String,
      type: EntityType.values.firstWhere(
        (e) => e.name == json['type'] as String,
        orElse: () => EntityType.task,
      ),
      title: json['title'] as String,
      data: json['data'] as Map<String, dynamic>,
      timestamp: DateTime.parse(json['timestamp'] as String),
      tags: List<String>.from(json['tags'] ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type.name,
      'title': title,
      'data': data,
      'timestamp': timestamp.toIso8601String(),
      'tags': tags,
    };
  }
}

================
File: features/chat/domain/models/message.dart
================
import 'entity.dart';

enum MessageType { text, entity, system }

class Message {
  final String id;
  final String content;
  final MessageType type;
  final List<Entity> entities;
  final DateTime timestamp;
  final Map<String, dynamic>? tokenUsage;
  final String? threadId;

  const Message({
    required this.id,
    required this.content,
    required this.type,
    this.entities = const [],
    required this.timestamp,
    this.tokenUsage,
    this.threadId,
  });

  factory Message.fromJson(Map<String, dynamic> json) {
    return Message(
      id: json['id'] as String,
      content: json['content'] as String,
      type: MessageType.values.firstWhere(
        (t) => t.name == json['type'] as String,
        orElse: () => MessageType.text,
      ),
      entities: (json['entities'] as List?)
              ?.map((e) => Entity.fromJson(e as Map<String, dynamic>))
              .toList() ??
          [],
      timestamp: DateTime.parse(json['timestamp'] as String),
      tokenUsage: json['token_usage'] as Map<String, dynamic>?,
      threadId: json['thread_id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'content': content,
      'type': type.name,
      'entities': entities.map((e) => e.toJson()).toList(),
      'timestamp': timestamp.toIso8601String(),
      if (tokenUsage != null) 'token_usage': tokenUsage,
      if (threadId != null) 'thread_id': threadId,
    };
  }
}
