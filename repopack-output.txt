================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-11-03T09:54:11.346Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
core/
  config/
    app_config.dart
  errors/
    exceptions.dart
  network/
    api_client.dart
  providers/
    core_providers.dart
  storage/
    session_storage.dart
  theme/
    app_colors.dart
    app_theme.dart
    app_typography.dart
    theme.dart
  widgets/
    app_logo.dart
    buttons.dart
features/
  auth/
    data/
      session_manager.dart
    domain/
      user.dart
    presentation/
      providers/
        auth_provider.dart
  chat/
    data/
      chat_service.dart
    domain/
      models/
        entity_base.dart
        entity_factory.dart
        entity.dart
        message.dart
        note_entity.dart
        person_entity.dart
        task_entity.dart
        topic_entity.dart
    presentation/
      providers/
        chat_provider.dart
        entity_provider.dart
      chat_screen.dart
      splash_screen.dart
    widgets/
      entity/
        base_entity_card.dart
        entity_card_factory.dart
        entity_detail_view.dart
        note_card.dart
        person_card.dart
        task_card.dart
        topic_card.dart
      message_list.dart
      search_input.dart
shared/
  widgets/
    app_button.dart
main.dart

================================================================
Repository Files
================================================================

================
File: main.dart
================
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'core/storage/session_storage.dart';
import 'core/network/api_client.dart';
import 'core/theme/theme.dart'; // Import our new theme
import 'features/chat/presentation/chat_screen.dart';
import 'features/auth/presentation/providers/auth_provider.dart';
import 'features/chat/presentation/splash_screen.dart';
import 'core/providers/core_providers.dart';

void main() async {
  try {
    // Ensure Flutter bindings are initialized
    WidgetsFlutterBinding.ensureInitialized();

    // Initialize Hive
    await Hive.initFlutter();

    // Initialize session storage
    final sessionStorage = SessionStorage();
    await sessionStorage.init();

    // Initialize API client
    final apiClient = ApiClient();

    // Run app with providers
    runApp(
      ProviderScope(
        overrides: [
          // Override the API client provider with our initialized instance
          apiClientProvider.overrideWithValue(apiClient),
          // Override the session storage provider with our initialized instance
          sessionStorageProvider.overrideWithValue(sessionStorage),
        ],
        child: const FlywallApp(),
      ),
    );
  } catch (e, stackTrace) {
    debugPrint('Error during app initialization: $e');
    debugPrint('Stack trace: $stackTrace');

    // Show error UI if initialization fails
    runApp(
      MaterialApp(
        theme: AppTheme.darkTheme, // Use our dark theme for error screen
        home: Scaffold(
          backgroundColor: AppColors.black,
          body: Center(
            child: Padding(
              padding: const EdgeInsets.all(32.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    color: AppColors.yellow,
                    size: 64,
                  ),
                  const SizedBox(height: 24),
                  Text(
                    'Failed to initialize app',
                    style: AppTypography.heading2,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    e.toString(),
                    style: AppTypography.body.copyWith(
                      color: AppColors.yellow,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class FlywallApp extends ConsumerWidget {
  const FlywallApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);

    return MaterialApp(
      title: 'Flywall',
      theme: AppTheme.darkTheme, // Use our new theme
      debugShowCheckedModeBanner: false, // Remove debug banner
      home: authState.status == AuthStatus.authenticated
          ? const ChatScreen()
          : const SplashScreen(),
    );
  }
}

================
File: core/errors/exceptions.dart
================
abstract class AppException implements Exception {
  const AppException(this.message);
  final String message;
}

class AuthException extends AppException {
  const AuthException(super.message);
}

class NetworkException extends AppException {
  const NetworkException(super.message);
}

class StorageException extends AppException {
  const StorageException(super.message);
}

================
File: core/config/app_config.dart
================
// lib/core/config/app_config.dart
class AppConfig {
  static const bool useLocalHost = false; // Set to false for production

  // API Configuration
  static String get baseUrl => useLocalHost
      ? 'http://10.0.2.2:8000' // Android emulator localhost
      : 'https://fapi.nyn.sh'; // Production API

  static const String apiVersion = 'v1';
  static String get apiPath => '/api/$apiVersion';

  // API Endpoints
  static String get authEndpoint => '$baseUrl/auth';
  static String get tokenEndpoint => '$authEndpoint/token';
  static String get registerEndpoint => '$authEndpoint/register';
  static String get userEndpoint => '$authEndpoint/users/me';
  static String get sidekickEndpoint => '$baseUrl$apiPath/sidekick';

  // WebSocket Configuration
  static String get wsUrl =>
      useLocalHost ? 'ws://10.0.2.2:8000/ws' : 'wss://fapi.nyn.sh/ws';

  // Storage keys
  static const String sessionBoxName = 'flywall_session';
  static const String userSecretKey = 'user_secret';
  static const String threadIdKey = 'thread_id';

  // Timeouts
  static const Duration connectionTimeout = Duration(seconds: 30);
  static const Duration receiveTimeout = Duration(seconds: 30);

  // Error Messages
  static const String networkErrorMessage =
      'Unable to connect to the server. Please check your internet connection.';
  static const String serverErrorMessage =
      'Something went wrong on our end. Please try again later.';
  static const String authErrorMessage =
      'Authentication failed. Please try again.';
}

================
File: core/providers/core_providers.dart
================
// lib/core/providers/core_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../network/api_client.dart';
import '../storage/session_storage.dart';

/// Core API client provider
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient());

/// Session storage provider
final sessionStorageProvider =
    Provider<SessionStorage>((ref) => SessionStorage());

================
File: core/storage/session_storage.dart
================
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../config/app_config.dart';

class SessionStorage {
  late Box _box;

  static const String userNameKey = 'user_name';

  Future<void> init() async {
    _box = await Hive.openBox(AppConfig.sessionBoxName);
    debugPrint('Session storage initialized: ${hasSession()}');
  }

  // User name methods
  Future<void> saveUserName(String name) async {
    await _box.put(userNameKey, name);
    debugPrint('User name saved: $name');
  }

  Future<String?> getUserName() async {
    final name = _box.get(userNameKey) as String?;
    debugPrint('Retrieved user name: $name');
    return name;
  }

  // User secret methods
  Future<void> saveUserSecret(String secret) async {
    await _box.put(AppConfig.userSecretKey, secret);
    debugPrint('User secret saved: $secret');
  }

  Future<String?> getUserSecret() async {
    final secret = _box.get(AppConfig.userSecretKey) as String?;
    debugPrint('Retrieved user secret: $secret');
    return secret;
  }

  // Thread ID methods
  Future<void> saveThreadId(String? threadId) async {
    if (threadId != null) {
      await _box.put(AppConfig.threadIdKey, threadId);
      debugPrint('Thread ID saved: $threadId');
    } else {
      await _box.delete(AppConfig.threadIdKey);
      debugPrint('Thread ID cleared');
    }
  }

  Future<String?> getThreadId() async {
    final threadId = _box.get(AppConfig.threadIdKey) as String?;
    debugPrint('Retrieved thread ID: $threadId');
    return threadId;
  }

  // Session management methods
  Future<void> clearSession() async {
    await _box.clear(); // This will clear everything including the user name
    debugPrint('Session cleared');
  }

  bool hasSession() {
    final hasSecret = _box.containsKey(AppConfig.userSecretKey);
    debugPrint('Has session: $hasSecret');
    return hasSecret;
  }

  // Helper method to check if we have a stored name
  bool hasUserName() {
    final hasName = _box.containsKey(userNameKey);
    debugPrint('Has user name: $hasName');
    return hasName;
  }
}

================
File: core/network/api_client.dart
================
// lib/core/network/api_client.dart
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../errors/exceptions.dart';

class ApiClient {
  late final Dio _dio;

  ApiClient() {
    _dio = Dio(BaseOptions(
      connectTimeout: AppConfig.connectionTimeout,
      receiveTimeout: AppConfig.receiveTimeout,
      validateStatus: (status) => status != null && status < 500,
    ));

    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        return handler.next(options);
      },
      onResponse: (response, handler) {
        return handler.next(response);
      },
      onError: (DioException e, handler) async {
        if (e.type == DioExceptionType.connectionTimeout ||
            e.type == DioExceptionType.receiveTimeout) {
          if (e.requestOptions.extra['retryCount'] == null ||
              e.requestOptions.extra['retryCount'] < 3) {
            final options = e.requestOptions;
            options.extra['retryCount'] =
                (options.extra['retryCount'] ?? 0) + 1;
            return handler.resolve(await _dio.fetch(options));
          }
        }
        return handler.next(e);
      },
    ));
  }

  Future<Response<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.get<T>(
        path,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.post<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> put<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.put<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> delete<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.delete<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  AppException _handleError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return const NetworkException(AppConfig.networkErrorMessage);

      case DioExceptionType.badResponse:
        if (e.response?.statusCode == 401) {
          return const AuthException(AppConfig.authErrorMessage);
        }
        return NetworkException(
            e.response?.statusMessage ?? AppConfig.serverErrorMessage);

      default:
        return const NetworkException(AppConfig.networkErrorMessage);
    }
  }

  void setAuthToken(String token) {
    _dio.options.headers['Authorization'] = 'Bearer $token';
  }

  void clearAuthToken() {
    _dio.options.headers.remove('Authorization');
  }
}

================
File: core/widgets/app_logo.dart
================
// lib/core/widgets/app_logo.dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../theme/theme.dart';

const logoSvg =
    '''<svg width="101" height="94" viewBox="0 0 101 94" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M35.8 93.84L10.36 75.6L31 53.04L29.08 52.56L29.32 52.8L0.76001 47.28L10.36 17.28L38.44 30.24L36.52 14.16C36.2 11.44 35.88 8.96 35.56 6.72C35.4 4.32 35.16 2.08 34.84 0H66.52L62.92 30.24L77.8 23.28C80.36 22 82.68 20.88 84.76 19.92C87 18.8 89.08 17.84 91 17.04L100.6 47.04L70.6 53.04L91.48 75.36L65.32 93.36L50.68 67.2L47.8 72.72L35.8 93.84ZM34.6 87.84L44.2 70.8C45.32 68.72 46.36 66.8 47.32 65.04C48.44 63.12 49.64 61.12 50.92 59.04L66.76 87.36L85.24 74.64C81.56 70.96 77.8 66.96 73.96 62.64L62.68 50.4L95.08 43.92L88.6 22.8L58.12 36.96L61.72 4.08H39.64C40.12 9.2 40.68 14.72 41.32 20.64C42.12 26.4 42.92 32 43.72 37.44L13 22.8L6.28001 43.92C9.96001 44.72 13.88 45.52 18.04 46.32C22.36 47.12 26.28 47.84 29.8 48.48L38.92 50.16L16.6 74.88L34.6 87.84ZM33.88 84.72L19.72 74.4L43 48.96C40.28 48.48 37.48 48 34.6 47.52C31.88 46.88 29 46.24 25.96 45.6C22.92 44.96 19.96 44.4 17.08 43.92C14.36 43.28 11.64 42.8 8.92001 42.48L14.44 25.68L45.88 40.56L42.04 5.99999H59.56L55.48 40.32L86.92 25.68L92.44 42.48L58.36 48.96L82.12 74.16L67.72 84.24L50.92 54.48L42.52 69.6C39.48 74.56 36.6 79.6 33.88 84.72Z" fill="#14AE5C"/>
</svg>''';

class MiniAppLogo extends StatelessWidget {
  final bool animate;
  final Animation<double>? sizeAnimation;
  final Animation<Offset>? slideAnimation;
  final VoidCallback? onTap;

  const MiniAppLogo({
    super.key,
    this.animate = false,
    this.sizeAnimation,
    this.slideAnimation,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final logo = GestureDetector(
      onTap: onTap,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          SvgPicture.string(
            logoSvg,
            width: 32,
            height: 32,
          ),
          const SizedBox(width: 12),
          const Text.rich(
            TextSpan(
              children: [
                TextSpan(
                  text: 'SIDE',
                  style: TextStyle(
                    fontFamily: 'Blacker Display',
                    fontSize: 24,
                    fontWeight: FontWeight.w300,
                    fontStyle: FontStyle.italic,
                    color: AppColors.textSecondary,
                    height: 1,
                  ),
                ),
                TextSpan(
                  text: 'KICK',
                  style: TextStyle(
                    fontFamily: 'Blacker Display',
                    fontSize: 24,
                    fontWeight: FontWeight.w900,
                    color: AppColors.textPrimary,
                    height: 1,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );

    if (!animate) return logo;

    return SlideTransition(
      position: slideAnimation!,
      child: ScaleTransition(
        scale: sizeAnimation!,
        child: logo,
      ),
    );
  }
}

class AppLogo extends StatefulWidget {
  final bool isExpanded;
  final VoidCallback? onAnimationComplete;

  const AppLogo({
    super.key,
    this.isExpanded = true,
    this.onAnimationComplete,
  });

  @override
  State<AppLogo> createState() => _AppLogoState();
}

class _AppLogoState extends State<AppLogo> with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _scaleAnimation;
  late final Animation<Offset> _logoOffsetAnimation;
  late final Animation<Offset> _textOffsetAnimation;
  late final Animation<double> _subtitleOpacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 1.0,
      end: 32 / 80,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    // Logo movement (unchanged as it's working correctly)
    _logoOffsetAnimation = Tween<Offset>(
      begin: const Offset(0, 0),
      end: const Offset(-0.6, -0.8),
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    // Adjusted text movement to reach the same height as logo
    _textOffsetAnimation = Tween<Offset>(
      begin: const Offset(0, 1.2),
      end: const Offset(0.1, -2.88), // Increased upward movement
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    // Increased upward movement for subtitle
    _subtitleOpacityAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.0, 0.3, curve: Curves.easeOut),
    ));

    if (!widget.isExpanded) {
      _controller.value = 1.0;
    }
  }

  @override
  void didUpdateWidget(AppLogo oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isExpanded != oldWidget.isExpanded) {
      if (widget.isExpanded) {
        _controller.reverse();
      } else {
        _controller.forward();
      }
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        // Calculate height based on animation state
        final height = _controller.value > 0 ? 40.0 : 200.0;

        return SizedBox(
          width: MediaQuery.of(context).size.width,
          height: height,
          child: Stack(
            alignment: Alignment.topCenter,
            clipBehavior: Clip.none,
            children: [
              // Logo
              Positioned(
                top: 0,
                child: SlideTransition(
                  position: _logoOffsetAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: SvgPicture.string(
                      logoSvg,
                      width: 80,
                      height: 80,
                    ),
                  ),
                ),
              ),

              // Text
              Positioned(
                top: 100,
                child: SlideTransition(
                  position: _textOffsetAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: const Text.rich(
                      TextSpan(
                        children: [
                          TextSpan(
                            text: 'SIDE',
                            style: TextStyle(
                              fontFamily: 'Blacker Display',
                              fontSize: 56,
                              fontWeight: FontWeight.w300,
                              fontStyle: FontStyle.italic,
                              color: AppColors.textSecondary,
                              height: 1,
                            ),
                          ),
                          TextSpan(
                            text: 'KICK',
                            style: TextStyle(
                              fontFamily: 'Blacker Display',
                              fontSize: 56,
                              fontWeight: FontWeight.w900,
                              color: AppColors.textPrimary,
                              height: 1,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),

              // Subtitle with increased upward movement
              Positioned(
                top: 126,
                child: SlideTransition(
                  position: Tween<Offset>(
                    begin: Offset.zero,
                    end: const Offset(0, -1.5),
                  ).animate(CurvedAnimation(
                    parent: _controller,
                    curve: const Interval(0.0, 0.3, curve: Curves.easeOut),
                  )),
                  child: FadeTransition(
                    opacity: _subtitleOpacityAnimation,
                    child: Text(
                      'Remember everything',
                      style: AppTypography.subtitle,
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

================
File: core/widgets/buttons.dart
================
// lib/core/widgets/buttons.dart
import 'package:flutter/material.dart';
import '../theme/theme.dart';

class OutlinedActionButton extends StatelessWidget {
  final String text;
  final Color color;
  final VoidCallback? onPressed;

  const OutlinedActionButton({
    super.key,
    required this.text,
    required this.color,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return OutlinedButton(
      onPressed: onPressed,
      style: OutlinedButton.styleFrom(
        side: BorderSide(color: color, width: 1),
        padding: const EdgeInsets.symmetric(
          horizontal: 32,
          vertical: 16,
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(50),
        ),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            text,
            style: AppTypography.buttonAction.copyWith(color: color),
          ),
          const SizedBox(width: 8),
          Icon(
            Icons.arrow_forward,
            color: color,
            size: 20,
          ),
        ],
      ),
    );
  }
}

class BottomRowButton extends StatelessWidget {
  final String text;
  final Color color;
  final VoidCallback? onPressed;
  final bool showDivider;
  final bool showSpinner;

  const BottomRowButton({
    super.key,
    required this.text,
    required this.color,
    required this.onPressed,
    this.showDivider = true,
    this.showSpinner = false,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (showDivider)
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Container(
              height: 1,
              color: AppColors.white,
            ),
          ),
        Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onPressed,
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 24,
                vertical: 18,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text(
                    text,
                    style: AppTypography.button.copyWith(
                      color: onPressed == null ? AppColors.textDisabled : color,
                    ),
                  ),
                  if (showSpinner)
                    SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation(color),
                      ),
                    )
                  else
                    Transform.rotate(
                      angle: -45 * 3.14 / 180,
                      child: Icon(
                        Icons.arrow_forward,
                        color:
                            onPressed == null ? AppColors.textDisabled : color,
                        size: 20,
                      ),
                    ),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}

================
File: core/theme/app_colors.dart
================
// lib/core/theme/app_colors.dart
import 'package:flutter/material.dart';

class AppColors {
  // Core Colors
  static const black = Color(0xFF000000);
  static const white = Color(0xFFFFFFFF);

  // Accent Colors
  static const green = Color(0xFF14AE5C);
  static const yellow = Color(0xFFE5A000);
  static const grey = Color(0xFF7F7F7F);

  // Text Colors (used by typography)
  static const textPrimary = white;
  static const textSecondary = grey;
  static final textDisabled = white.withOpacity(0.3);
}

================
File: core/theme/app_theme.dart
================
// lib/core/theme/app_theme.dart
import 'package:flutter/material.dart';
import 'app_colors.dart';
import 'app_typography.dart';

class AppTheme {
  static ThemeData get darkTheme {
    return ThemeData(
      brightness: Brightness.dark,
      scaffoldBackgroundColor: AppColors.black,
      primaryColor: AppColors.yellow,
      colorScheme: const ColorScheme.dark(
        primary: AppColors.yellow,
        secondary: AppColors.green,
        surface: AppColors.black,
        background: AppColors.black,
        error: Colors.red,
      ),
      textTheme: TextTheme(
        displayLarge: AppTypography.megaTitle,
        displayMedium: AppTypography.logo,
        headlineMedium: AppTypography.heading1,
        headlineSmall: AppTypography.heading2,
        titleLarge: AppTypography.subtitle,
        bodyLarge: AppTypography.body,
        bodyMedium: AppTypography.body,
        labelSmall: AppTypography.caption,
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppColors.white.withOpacity(0.1),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: AppColors.yellow, width: 2),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 24,
          vertical: 20,
        ),
        hintStyle: AppTypography.input.copyWith(
          color: AppColors.black.withOpacity(0.3),
        ),
      ),
    );
  }
}

================
File: core/theme/app_typography.dart
================
// lib/core/theme/app_typography.dart
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppTypography {
  static const blackerDisplay = 'Blacker Display';
  static const graphik = 'Graphik';

  // Core text styles (used by theme system)
  static TextStyle get megaTitle => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 126,
        fontWeight: FontWeight.w900,
        color: AppColors.textPrimary,
        height: 1,
      );

  static TextStyle get logo => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 56,
        fontWeight: FontWeight.w900,
        color: AppColors.textPrimary,
        height: 1,
      );

  static TextStyle get logoItalic => logo.copyWith(
        fontWeight: FontWeight.w300,
        fontStyle: FontStyle.italic,
        color: AppColors.textSecondary,
      );

  static TextStyle get heading1 => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 42,
        fontWeight: FontWeight.w700,
        color: AppColors.textPrimary,
        height: 1.2,
      );

  static TextStyle get heading2 => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 32,
        fontWeight: FontWeight.w700,
        color: AppColors.textPrimary,
        height: 1.2,
      );

  static TextStyle get subtitle => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 28,
        fontWeight: FontWeight.w400,
        color: AppColors.textPrimary,
        height: 1.3,
      );

  static TextStyle get body => const TextStyle(
        fontFamily: graphik,
        fontSize: 14,
        fontWeight: FontWeight.w400,
        color: AppColors.textPrimary,
        height: 1.5,
      );

  static TextStyle get caption => const TextStyle(
        fontFamily: graphik,
        fontSize: 12,
        fontWeight: FontWeight.w300,
        color: AppColors.textSecondary,
        height: 1.4,
      );

  // Input styles
  static TextStyle get input => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 32,
        fontWeight: FontWeight.w700,
        color: AppColors.black,
        height: 1,
      );

  static TextStyle get inputLabel => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 21,
        fontWeight: FontWeight.w700,
        color: AppColors.black,
        height: 1.2,
      );

  // Button styles
  static TextStyle get button => const TextStyle(
        fontFamily: graphik,
        fontSize: 22,
        fontWeight: FontWeight.w300,
        height: 1,
      );

  static TextStyle get buttonAction => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 22,
        fontWeight: FontWeight.w500,
        height: 1,
      );

  static TextStyle get buttonSerif => button;

  static TextStyle get welcomeText => const TextStyle(
        fontFamily: blackerDisplay,
        fontSize: 21, // 2/3 of heading2's 32px
        fontWeight: FontWeight.w700,
        color: AppColors.textPrimary,
        height: 1.3,
      );

  static TextStyle get inputAction => buttonAction.copyWith(
        fontSize: 18, // 20% smaller than buttonAction's 22px
      );
}

================
File: core/theme/theme.dart
================
export 'app_colors.dart';
export 'app_typography.dart';
export 'app_theme.dart';

================
File: shared/widgets/app_button.dart
================
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isOutlined;

  const AppButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isOutlined = false,
  });

  @override
  Widget build(BuildContext context) {
    final style = isOutlined
        ? OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          )
        : ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          );

    final child = isLoading
        ? const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          )
        : Text(text);

    return isOutlined
        ? OutlinedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          )
        : ElevatedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          );
  }
}

================
File: features/auth/data/session_manager.dart
================
// lib/features/auth/data/session_manager.dart
import 'package:flutter/foundation.dart';
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../../../core/storage/session_storage.dart';
import '../../../core/errors/exceptions.dart';
import '../domain/user.dart';
import 'package:dio/dio.dart';

class SessionManager {
  final ApiClient _apiClient;
  final SessionStorage _storage;
  User? _currentUser;

  SessionManager(this._apiClient, this._storage);

  User? get currentUser => _currentUser;

  Future<bool> login(String userSecret) async {
    try {
      debugPrint('Attempting login with secret: $userSecret');

      // Using form data instead of JSON for the token endpoint
      final response = await _apiClient.post(
        AppConfig.tokenEndpoint,
        data: {'user_secret': userSecret},
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
        ),
      );

      debugPrint('Login response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;

        if (data['screen_name'] != null) {
          await _storage.saveUserName(data['screen_name']);
        }
        // Save the access token and user secret
        await _storage.saveUserSecret(userSecret);

        // Store current user with token
        _currentUser = User(
          id: data['user_id'] ?? '',
          screenName: data['screen_name'] ?? '',
          accessToken: data['access_token'],
        );

        // Set the auth token for future requests
        _apiClient.setAuthToken(_currentUser!.accessToken!);

        // Fetch additional user info
        await _fetchUserInfo();

        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<bool> restoreWithSecret(String secret) async {
    try {
      debugPrint('Restoring session with provided secret');
      // Clear any existing session first
      await logout();
      // Attempt to login with the provided secret
      return login(secret);
    } catch (e) {
      debugPrint('Restore with secret error: $e');
      throw const AuthException('Invalid secret or session expired');
    }
  }

  Future<User> register(String screenName) async {
    try {
      debugPrint('Attempting registration for: $screenName');

      final response = await _apiClient.post(
        AppConfig.registerEndpoint,
        data: {'screen_name': screenName},
      );

      debugPrint('Registration response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        final userSecret = data['user_secret'];

        await _storage.saveUserName(screenName);
        // Immediately login with the received user_secret
        final loginSuccess = await login(userSecret);
        if (!loginSuccess) {
          throw const AuthException('Login failed after registration');
        }

        return _currentUser!;
      }
      throw const AuthException('Registration failed');
    } catch (e) {
      debugPrint('Registration error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<void> _fetchUserInfo() async {
    try {
      final response = await _apiClient.get(AppConfig.userEndpoint);
      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;

        if (data['screen_name'] != null) {
          await _storage.saveUserName(data['screen_name']);
        }

        _currentUser = _currentUser?.copyWith(
          screenName: data['screen_name'],
          // Add other fields as needed
        );
      }
    } catch (e) {
      debugPrint('Error fetching user info: $e');
    }
  }

  Future<void> logout() async {
    await _storage.clearSession();
    _currentUser = null;
    _apiClient.clearAuthToken();
  }

  Future<bool> restoreSession() async {
    try {
      final userSecret = await _storage.getUserSecret();
      debugPrint('Restoring session with stored secret: $userSecret');
      if (userSecret != null) {
        return login(userSecret);
      }
      return false;
    } catch (e) {
      debugPrint('Restore session error: $e');
      return false;
    }
  }
}

================
File: features/auth/domain/user.dart
================
class User {
  final String id;
  final String screenName;
  final String? accessToken;

  const User({
    required this.id,
    required this.screenName,
    this.accessToken,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      screenName: json['screen_name'] as String,
      accessToken: json['access_token'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'screen_name': screenName,
      if (accessToken != null) 'access_token': accessToken,
    };
  }

  User copyWith({
    String? screenName,
  }) {
    return User(
      id: id,
      screenName: screenName ?? this.screenName,
      accessToken: accessToken,
    );
  }
}

================
File: features/chat/widgets/message_list.dart
================
import 'package:flutter/material.dart';
import '../presentation/providers/chat_provider.dart';
import 'entity/entity_card_factory.dart';
import '../domain/models/entity_base.dart';
import '../../../core/theme/theme.dart';

class MessageList extends StatelessWidget {
  final List<ChatMessage> messages;
  final ScrollController scrollController;
  final bool isThreadComplete;

  const MessageList({
    super.key,
    required this.messages,
    required this.scrollController,
    required this.isThreadComplete,
  });

  @override
  Widget build(BuildContext context) {
    final reversedMessages = messages.reversed.toList();

    return ListView.builder(
      controller: scrollController,
      reverse: true,
      padding: const EdgeInsets.only(
        left: 24,
        right: 24,
        top: 20,
        bottom: 8,
      ),
      itemCount: reversedMessages.length + (isThreadComplete ? 1 : 0),
      itemBuilder: (context, index) {
        if (index == 0 && isThreadComplete) {
          return _buildThreadCompleteMessage();
        }

        final message = reversedMessages[index - (isThreadComplete ? 1 : 0)];
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 12.0),
          child: Column(
            crossAxisAlignment: message.isUserMessage
                ? CrossAxisAlignment.start
                : CrossAxisAlignment.end,
            children: [
              _buildMessageBubble(context, message),
              if (!message.isUserMessage) ...[
                const SizedBox(height: 4),
                _buildTokenUsage(message.tokenUsage),
              ],
              if (!message.isUserMessage && message.entities.isNotEmpty)
                _buildEntityCards(message.entities),
            ],
          ),
        );
      },
    );
  }

  Widget _buildThreadCompleteMessage() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 24.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 33,
            height: 1,
            color: const Color(0xFF009951),
          ),
          const SizedBox(width: 8),
          Text(
            'end of thread',
            style: AppTypography.body.copyWith(
              color: const Color(0xFF009951),
              fontSize: 14,
              fontFamily: 'Blacker Display',
              fontWeight: FontWeight.w400,
              height: 1,
            ),
          ),
          const SizedBox(width: 8),
          Container(
            width: 33,
            height: 1,
            color: const Color(0xFF009951),
          ),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(BuildContext context, ChatMessage message) {
    return Container(
      constraints: BoxConstraints(
        maxWidth: MediaQuery.of(context).size.width * 0.75,
      ),
      child: Text(
        message.content,
        style: AppTypography.welcomeText.copyWith(
          color: message.isUserMessage ? Colors.white : const Color(0xFFE5A000),
        ),
      ),
    );
  }

  Widget _buildTokenUsage(Map<String, dynamic>? tokenUsage) {
    if (tokenUsage == null) return const SizedBox.shrink();

    return Text(
      'token usage ${tokenUsage['prompt_tokens'] ?? 0} + ${tokenUsage['completion_tokens'] ?? 0}',
      style: AppTypography.caption.copyWith(
        color: const Color(0xFFE5A000),
        fontSize: 12,
      ),
    );
  }

  Widget _buildEntityCards(List<EntityBase> entities) {
    return Padding(
      padding: const EdgeInsets.only(top: 12),
      child: SizedBox(
        height: 140,
        child: ListView.separated(
          scrollDirection: Axis.horizontal,
          itemCount: entities.length,
          separatorBuilder: (context, index) => const SizedBox(width: 12),
          itemBuilder: (context, index) => EntityCardFactory.createCard(
            entities[index],
            onTap: () {
              // Your existing onTap logic here if any
            },
          ),
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/search_input.dart
================
import 'package:flutter/material.dart';
import '../../../core/theme/theme.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../../../core/widgets/app_logo.dart';

class SearchInput extends StatefulWidget {
  final Function(String) onSubmitted;
  final bool enabled;
  final bool isThreadActive;

  const SearchInput({
    super.key,
    required this.onSubmitted,
    this.enabled = true,
    this.isThreadActive = false,
  });

  @override
  State<SearchInput> createState() => _SearchInputState();
}

class _SearchInputState extends State<SearchInput>
    with SingleTickerProviderStateMixin {
  final TextEditingController _controller = TextEditingController();
  bool _hasText = false;
  late final AnimationController _spinController;

  @override
  void initState() {
    super.initState();
    _controller.addListener(_updateHasText);
    _spinController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    )..repeat();
  }

  @override
  void dispose() {
    _controller.removeListener(_updateHasText);
    _controller.dispose();
    _spinController.dispose();
    super.dispose();
  }

  void _updateHasText() {
    setState(() {
      _hasText = _controller.text.trim().isNotEmpty;
    });
  }

  void _handleSubmit() {
    final text = _controller.text.trim();
    if (text.isNotEmpty && widget.enabled) {
      widget.onSubmitted(text);
      _controller.clear();
      _updateHasText();
    }
  }

  Widget _buildSpinningLogo() {
    return AnimatedBuilder(
      animation: _spinController,
      builder: (context, child) {
        return Transform.rotate(
          angle: _spinController.value * 4 * 3.14159,
          child: SvgPicture.string(
            logoSvg,
            width: 20,
            height: 20,
            color: AppColors.white,
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Container(
            height: 1,
            color: AppColors.white,
          ),
        ),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24),
          child: Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _controller,
                  enabled: widget.enabled,
                  style: AppTypography.inputAction.copyWith(
                    color: AppColors.white,
                  ),
                  decoration: InputDecoration(
                    hintText:
                        widget.enabled ? 'Ask anything...' : 'Please wait...',
                    hintStyle: AppTypography.inputAction.copyWith(
                      color: AppColors.textSecondary,
                    ),
                    border: InputBorder.none,
                    focusedBorder: InputBorder.none,
                    enabledBorder: InputBorder.none,
                    errorBorder: InputBorder.none,
                    disabledBorder: InputBorder.none,
                    fillColor: Colors.transparent,
                    filled: false,
                    contentPadding: const EdgeInsets.symmetric(vertical: 18),
                  ),
                  onSubmitted: (_) => _handleSubmit(),
                  maxLines: null,
                ),
              ),
              if (!widget.enabled)
                _buildSpinningLogo()
              else
                GestureDetector(
                  onTap: _hasText ? _handleSubmit : null,
                  child: Transform.rotate(
                    angle: -45 * 3.14 / 180,
                    child: Icon(
                      Icons.arrow_forward,
                      color:
                          _hasText ? AppColors.white : AppColors.textDisabled,
                      size: 20,
                    ),
                  ),
                ),
            ],
          ),
        ),
      ],
    );
  }
}

================
File: features/auth/presentation/providers/auth_provider.dart
================
// lib/features/auth/presentation/providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/session_manager.dart';
import '../../domain/user.dart';
import '../../../../core/providers/core_providers.dart';

// Session manager provider
final sessionManagerProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  final storage = ref.watch(sessionStorageProvider);
  return SessionManager(apiClient, storage);
});

// Auth state
enum AuthStatus { initial, loading, authenticated, error }

class AuthState {
  final AuthStatus status;
  final User? user;
  final String? error;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.error,
  });

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      error: error,
    );
  }
}

class AuthNotifier extends StateNotifier<AuthState> {
  final SessionManager _sessionManager;

  AuthNotifier(this._sessionManager) : super(const AuthState());

  void setAuthenticated(User user) {
    state = AuthState(
      status: AuthStatus.authenticated,
      user: user,
    );
  }

  Future<bool> checkAuth([String? secret]) async {
    try {
      state = state.copyWith(status: AuthStatus.loading);

      // If secret is provided, use it for restoration
      final success = secret != null
          ? await _sessionManager.restoreWithSecret(secret)
          : await _sessionManager.restoreSession();

      if (success) {
        state = state.copyWith(
          status: AuthStatus.authenticated,
          user: _sessionManager.currentUser,
        );
      } else {
        state = state.copyWith(
          status: AuthStatus.error,
          error: 'Invalid secret or session expired',
        );
      }

      return success;
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
      return false;
    }
  }

  Future<void> registerAndLogin(String name) async {
    try {
      state = state.copyWith(status: AuthStatus.loading);
      final user = await _sessionManager.register(name);
      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
      );
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
    }
  }

  Future<void> logout() async {
    await _sessionManager.logout();
    state = const AuthState(status: AuthStatus.initial);
  }
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final sessionManager = ref.watch(sessionManagerProvider);
  return AuthNotifier(sessionManager);
});

================
File: features/chat/presentation/chat_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart';
import '../widgets/search_input.dart';
import '../widgets/message_list.dart';
import '../widgets/entity/entity_detail_view.dart';
import 'providers/chat_provider.dart';
import 'providers/entity_provider.dart';
import '../../../core/providers/core_providers.dart';
import '../../../core/theme/theme.dart';
import '../../../core/widgets/app_logo.dart';

class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({super.key});

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  final scrollController = ScrollController();
  String? _userName;
  String? _userSecret;
  bool _isKeyboardVisible = false;

  @override
  void initState() {
    super.initState();
    _loadUserData();
  }

  Future<void> _loadUserData() async {
    final storage = ref.read(sessionStorageProvider);
    final userName = await storage.getUserName();
    final userSecret = await storage.getUserSecret();
    if (mounted) {
      setState(() {
        _userName = userName;
        _userSecret = userSecret;
      });
    }
  }

  void _scrollToBottom() {
    if (scrollController.hasClients) {
      scrollController.animateTo(
        scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  void _copySecretToClipboard() async {
    if (_userSecret != null) {
      await Clipboard.setData(ClipboardData(text: _userSecret!));
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Secret copied to clipboard'),
            duration: Duration(seconds: 2),
            backgroundColor: AppColors.green,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatState = ref.watch(chatProvider);
    final selectedEntity = ref.watch(selectedEntityProvider);
    final hasMessages = chatState.messages.isNotEmpty;
    final isThreadComplete =
        chatState.messages.lastOrNull?.isThreadComplete ?? false;

    // Listen for changes and scroll to bottom when new messages arrive
    ref.listen<ChatState>(chatProvider, (previous, next) {
      if (previous?.messages.length != next.messages.length) {
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
      }

      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error!), backgroundColor: Colors.red),
        );
      }
    });

    // Listen to keyboard visibility
    _isKeyboardVisible = MediaQuery.of(context).viewInsets.bottom > 0;

    return Scaffold(
      backgroundColor: AppColors.black,
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                const SizedBox(height: 48),
                // Logo Section with tap handler
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 32),
                  child: hasMessages
                      ? MiniAppLogo(onTap: _copySecretToClipboard)
                      : AppLogo(
                          isExpanded: !_isKeyboardVisible,
                        ),
                ),

                if (!hasMessages) ...[
                  const Spacer(),
                  // Welcome Message with new style
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 62),
                    child: Text(
                      'I can help with your existing information\n\nor help create new topics, tasks or notes.',
                      textAlign: TextAlign.center,
                      style: AppTypography.welcomeText.copyWith(
                        color: AppColors.yellow,
                      ),
                    ),
                  ),
                  const SizedBox(height: 10),
                ] else
                  Expanded(
                    child: MessageList(
                      messages: chatState.messages,
                      scrollController: scrollController,
                      isThreadComplete: isThreadComplete,
                    ),
                  ),

                // Input Section
                SearchInput(
                  onSubmitted: (input) {
                    if (input.trim().isNotEmpty) {
                      if (isThreadComplete) {
                        ref.read(chatProvider.notifier).clearThread();
                      }
                      ref.read(chatProvider.notifier).sendMessage(input);
                    }
                  },
                  enabled: !chatState.isLoading,
                  isThreadActive: hasMessages,
                ),
              ],
            ),

            // Entity Detail View
            if (selectedEntity != null)
              Positioned.fill(
                child: GestureDetector(
                  onTap: () =>
                      ref.read(selectedEntityProvider.notifier).state = null,
                  child: Container(
                    color: Colors.black54,
                    alignment: Alignment.center,
                    child: EntityDetailView(
                      entity: selectedEntity,
                      onClose: () => ref
                          .read(selectedEntityProvider.notifier)
                          .state = null,
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    scrollController.dispose();
    super.dispose();
  }
}

================
File: features/chat/presentation/splash_screen.dart
================
// lib/features/chat/presentation/splash_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/theme/theme.dart';
import '../../../core/widgets/app_logo.dart';
import '../../../core/widgets/buttons.dart';
import '../../auth/presentation/providers/auth_provider.dart';
import '../../../core/providers/core_providers.dart';
import 'package:flutter/services.dart';

// Separate widget for the bottom sheet
class AuthBottomSheet extends ConsumerStatefulWidget {
  final bool isRestore;

  const AuthBottomSheet({
    super.key,
    required this.isRestore,
  });

  @override
  ConsumerState<AuthBottomSheet> createState() => _AuthBottomSheetState();
}

class _AuthBottomSheetState extends ConsumerState<AuthBottomSheet> {
  late final TextEditingController _controller;
  bool _isLoading = false;
  bool _showWelcome = false;
  String? _enteredValue;
  String? _actualSecret; // Store the actual secret separately
  bool _showTextField = true;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController();
    _controller.addListener(_onTextChanged);
  }

  @override
  void dispose() {
    _controller.removeListener(_onTextChanged);
    _controller.dispose();
    super.dispose();
  }

  void _onTextChanged() {
    setState(() {
      _enteredValue = _controller.text.trim();
    });
  }

  void _showError(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  String _formatSecretText(String text) {
    if (text.length <= 6) return text;
    return '${text.substring(0, 3)}${text.substring(text.length - 3)}';
  }

  Future<void> _pasteFromClipboard() async {
    final clipboardData = await Clipboard.getData(Clipboard.kTextPlain);
    if (clipboardData?.text != null) {
      setState(() {
        _actualSecret = clipboardData!.text!.trim(); // Store actual secret
        _controller.text =
            _formatSecretText(_actualSecret!); // Show formatted version
        _enteredValue = _actualSecret; // Use this for authentication
      });
    }
  }

  Future<void> _handleAuth() async {
    if (_isLoading) return;

    final value = widget.isRestore ? _actualSecret : _controller.text;
    if (value?.isEmpty ?? true) {
      _showError(widget.isRestore
          ? 'Please enter your secret'
          : 'Please enter your name');
      return;
    }

    setState(() {
      _isLoading = true;
      _showWelcome = true;
      _showTextField = false;
      _enteredValue = value;
    });

    try {
      if (widget.isRestore) {
        await ref.read(authProvider.notifier).checkAuth(value);
      } else {
        await ref.read(authProvider.notifier).registerAndLogin(value!);
      }
    } catch (e) {
      if (mounted) {
        _showError(e.toString());
        setState(() {
          _isLoading = false;
          _showWelcome = false;
          _showTextField = true;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    ref.listen<AuthState>(
      authProvider,
      (previous, next) {
        if (!mounted) return;

        if (next.status == AuthStatus.authenticated) {
          Navigator.of(context).pop();
        }

        if (next.status == AuthStatus.error && next.error != null) {
          _showError(next.error!);
        }
      },
    );

    return Container(
      decoration: const BoxDecoration(
        color: AppColors.yellow,
        border: Border(
          top: BorderSide(color: AppColors.white, width: 1),
        ),
      ),
      child: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              AnimatedSize(
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeOut,
                child: Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      AnimatedSlide(
                        duration: const Duration(milliseconds: 300),
                        curve: Curves.easeOut,
                        offset:
                            _showTextField ? Offset.zero : const Offset(0, 0.2),
                        child: AnimatedCrossFade(
                          duration: const Duration(milliseconds: 300),
                          firstChild: Text(
                            widget.isRestore
                                ? 'Enter your secret'
                                : "What's your name?",
                            style: AppTypography.inputLabel.copyWith(
                              color: AppColors.black,
                            ),
                          ),
                          secondChild: Text(
                            widget.isRestore
                                ? 'Welcome back'
                                : 'Welcome, ${_enteredValue ?? ""}',
                            style: AppTypography.heading2.copyWith(
                              color: AppColors.black,
                            ),
                          ),
                          crossFadeState: _showWelcome
                              ? CrossFadeState.showSecond
                              : CrossFadeState.showFirst,
                        ),
                      ),
                      if (_showTextField) ...[
                        const SizedBox(height: 24),
                        AnimatedOpacity(
                          duration: const Duration(milliseconds: 200),
                          opacity: _showTextField ? 1.0 : 0.0,
                          child: SizedBox(
                            height: 64,
                            child: TextField(
                              controller: _controller,
                              style: AppTypography.input,
                              enabled: !_isLoading,
                              readOnly: widget.isRestore,
                              decoration: InputDecoration(
                                hintText: widget.isRestore
                                    ? 'Tap to paste your secret'
                                    : 'Enter your name',
                                hintStyle: AppTypography.input.copyWith(
                                  color: AppColors.black.withOpacity(0.3),
                                ),
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(12),
                                  borderSide: BorderSide.none,
                                ),
                                filled: true,
                                fillColor: AppColors.white.withOpacity(0.1),
                                isCollapsed: true,
                                contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 16,
                                  vertical: 12,
                                ),
                                suffixIcon: widget.isRestore
                                    ? IconButton(
                                        icon: const Icon(
                                          Icons.content_paste_rounded,
                                          color: AppColors.black,
                                        ),
                                        onPressed: _isLoading
                                            ? null
                                            : _pasteFromClipboard,
                                      )
                                    : null,
                              ),
                              onTap:
                                  widget.isRestore ? _pasteFromClipboard : null,
                              onSubmitted: (_) => _handleAuth(),
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              BottomRowButton(
                text: _isLoading
                    ? (widget.isRestore ? 'Restoring...' : 'Getting ready...')
                    : (widget.isRestore
                        ? 'Restore account'
                        : 'Setup my account'),
                color: AppColors.white,
                onPressed: _isLoading ? null : _handleAuth,
                showDivider: true,
                showSpinner: _isLoading,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  bool _isChecking = true;
  String? _userName;
  bool _hasSession = false;
  bool _isBottomSheetVisible = false;

  @override
  void initState() {
    super.initState();
    _checkExistingSession();
  }

  Future<void> _checkExistingSession() async {
    try {
      final storage = ref.read(sessionStorageProvider);
      final sessionManager = ref.read(sessionManagerProvider);

      // First quickly check if we have a username stored
      final userName = await storage.getUserName();
      if (mounted) {
        setState(() {
          _userName = userName;
          _isChecking =
              storage.hasSession(); // Only show loading if we have a session
        });
      }

      // Then attempt to restore the session if we have one
      if (storage.hasSession()) {
        final hasSession = await sessionManager.restoreSession();

        if (mounted) {
          setState(() {
            _hasSession = hasSession;
            _isChecking = false;
          });

          if (hasSession && sessionManager.currentUser != null) {
            ref.read(authProvider.notifier).setAuthenticated(
                  sessionManager.currentUser!,
                );
          }
        }
      } else {
        if (mounted) {
          setState(() {
            _isChecking = false;
            _hasSession = false;
          });
        }
      }
    } catch (e) {
      debugPrint('Error in session check: $e');
      if (mounted) {
        setState(() {
          _isChecking = false;
          _hasSession = false;
        });
        _showError('Error checking session: $e');
      }
    }
  }

  void _showError(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  Widget _buildLoadingScreen() {
    return Scaffold(
      backgroundColor: AppColors.black,
      body: SafeArea(
        child: Column(
          children: [
            const SizedBox(height: 48),
            // Logo Section
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 32),
              child: AppLogo(),
            ),

            const SizedBox(height: 80),

            // Welcome back text
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 62),
              child: Text(
                _userName != null ? 'Welcome back, $_userName' : 'Welcome back',
                textAlign: TextAlign.center,
                style: AppTypography.heading1.copyWith(
                  color: AppColors.yellow,
                  fontSize: 36,
                  fontWeight: FontWeight.w700,
                  height: 0,
                ),
              ),
            ),

            const Spacer(),

            // Loading indicator and text
            Padding(
              padding: const EdgeInsets.only(bottom: 120),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation(AppColors.white),
                    strokeWidth: 2,
                  ),
                  const SizedBox(height: 24),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 88),
                    child: Text(
                      'loading your profile',
                      textAlign: TextAlign.center,
                      style: AppTypography.subtitle.copyWith(
                        color: AppColors.white,
                        fontSize: 24,
                        fontWeight: FontWeight.w700,
                        height: 0,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showBottomSheet(bool isRestore) {
    setState(() => _isBottomSheetVisible = true);

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      isDismissible: !isRestore,
      builder: (context) => AuthBottomSheet(isRestore: isRestore),
    ).whenComplete(() {
      if (mounted) {
        setState(() => _isBottomSheetVisible = false);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_isChecking || _hasSession) {
      return _buildLoadingScreen();
    }

    return Scaffold(
      backgroundColor: AppColors.black,
      body: SafeArea(
        child: Column(
          children: [
            const SizedBox(height: 48),
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 32),
              child: AppLogo(),
            ),
            const Spacer(),
            // Animate the Get Started button
            AnimatedSlide(
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
              offset: _isBottomSheetVisible ? const Offset(0, 1) : Offset.zero,
              child: AnimatedOpacity(
                duration: const Duration(milliseconds: 200),
                opacity: _isBottomSheetVisible ? 0.0 : 1.0,
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 24),
                  child: OutlinedActionButton(
                    text: 'Get started',
                    color: AppColors.green,
                    onPressed: () => _showBottomSheet(false),
                  ),
                ),
              ),
            ),
            const Spacer(),
            // Keep Restore button at bottom
            Padding(
              padding: const EdgeInsets.only(bottom: 24),
              child: BottomRowButton(
                text: 'Restore',
                color: AppColors.yellow,
                onPressed: () => _showBottomSheet(true),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================
File: features/chat/domain/models/entity.dart
================
enum EntityType { task, note, person, topic }

class Entity {
  final String id;
  final EntityType type;
  final String title;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final List<String> tags;

  const Entity({
    required this.id,
    required this.type,
    required this.title,
    required this.data,
    required this.timestamp,
    this.tags = const [],
  });

  factory Entity.fromJson(Map<String, dynamic> json) {
    try {
      return Entity(
        id: json['id']?.toString() ??
            DateTime.now().microsecondsSinceEpoch.toString(),
        type: EntityType.values.firstWhere(
          (e) =>
              e.name.toLowerCase() == (json['type'] as String?)?.toLowerCase(),
          orElse: () => EntityType.task,
        ),
        title: json['title']?.toString() ?? 'Untitled',
        data: _sanitizeData(json['data']),
        timestamp: _parseDateTime(json['timestamp']) ?? DateTime.now(),
        tags: _parseTags(json['tags']),
      );
    } catch (e, stackTrace) {
      print('Error parsing Entity from JSON: $e\n$stackTrace');
      // Return a default entity if parsing fails
      return Entity(
        id: DateTime.now().microsecondsSinceEpoch.toString(),
        type: EntityType.task,
        title: 'Error: Invalid Entity',
        data: {'error': e.toString()},
        timestamp: DateTime.now(),
        tags: const [],
      );
    }
  }

  Map<String, dynamic> toJson() {
    try {
      return {
        'id': id,
        'type': type.name,
        'title': title,
        'data': data,
        'timestamp': timestamp.toIso8601String(),
        'tags': tags,
      };
    } catch (e) {
      print('Error converting Entity to JSON: $e');
      return {
        'id': id,
        'type': type.name,
        'title': title,
        'data': {},
        'timestamp': DateTime.now().toIso8601String(),
        'tags': [],
      };
    }
  }

  // Helper method to safely parse DateTime
  static DateTime? _parseDateTime(dynamic value) {
    if (value == null) return null;
    if (value is DateTime) return value;
    if (value is String) {
      try {
        return DateTime.parse(value);
      } catch (_) {
        try {
          // Try parsing timestamp as milliseconds since epoch
          return DateTime.fromMillisecondsSinceEpoch(int.parse(value));
        } catch (_) {
          return null;
        }
      }
    }
    if (value is int) {
      try {
        return DateTime.fromMillisecondsSinceEpoch(value);
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  // Helper method to safely parse tags
  static List<String> _parseTags(dynamic value) {
    if (value == null) return [];
    if (value is List) {
      return value
          .where((element) => element != null)
          .map((element) => element.toString())
          .toList();
    }
    if (value is String) {
      return [value];
    }
    return [];
  }

  // Helper method to sanitize data map
  static Map<String, dynamic> _sanitizeData(dynamic value) {
    if (value == null) return {};
    if (value is Map<String, dynamic>) {
      return Map<String, dynamic>.from(value.map((key, value) {
        // Convert null values to empty strings or appropriate defaults
        if (value == null) return MapEntry(key, '');
        if (value is Map) {
          return MapEntry(key, _sanitizeData(value));
        }
        if (value is List) {
          return MapEntry(key, _sanitizeList(value));
        }
        return MapEntry(key, value);
      }));
    }
    return {};
  }

  // Helper method to sanitize lists in data
  static List<dynamic> _sanitizeList(List list) {
    return list.map((item) {
      if (item == null) return '';
      if (item is Map) return _sanitizeData(item);
      if (item is List) return _sanitizeList(item);
      return item;
    }).toList();
  }

  // Convenience method to get a safely typed value from data
  T? getValue<T>(String key) {
    final value = data[key];
    if (value is T) return value;
    return null;
  }

  // Helper method to get a string value with a default
  String getStringValue(String key, {String defaultValue = ''}) {
    final value = data[key];
    if (value == null) return defaultValue;
    return value.toString();
  }

  // Helper method to check if a key exists and has a non-null value
  bool hasValue(String key) {
    return data.containsKey(key) && data[key] != null;
  }

  @override
  String toString() {
    return 'Entity{id: $id, type: $type, title: $title, timestamp: $timestamp, tags: $tags}';
  }

  // Create a copy of the entity with updated fields
  Entity copyWith({
    String? id,
    EntityType? type,
    String? title,
    Map<String, dynamic>? data,
    DateTime? timestamp,
    List<String>? tags,
  }) {
    return Entity(
      id: id ?? this.id,
      type: type ?? this.type,
      title: title ?? this.title,
      data: data ?? Map<String, dynamic>.from(this.data),
      timestamp: timestamp ?? this.timestamp,
      tags: tags ?? List<String>.from(this.tags),
    );
  }

  // Helper to create an empty entity of a specific type
  factory Entity.empty(EntityType type) {
    return Entity(
      id: DateTime.now().microsecondsSinceEpoch.toString(),
      type: type,
      title: 'New ${type.name}',
      data: {},
      timestamp: DateTime.now(),
      tags: [],
    );
  }
}

================
File: features/chat/domain/models/entity_base.dart
================
import 'package:flutter/foundation.dart';

enum EntityType { task, note, person, topic }

abstract class EntityBase {
  final String id;
  final EntityType type;
  final String title;
  final DateTime timestamp;
  final List<String> tags;

  const EntityBase({
    required this.id,
    required this.type,
    required this.title,
    required this.timestamp,
    this.tags = const [],
  });

  // Abstract method that each entity must implement
  Map<String, dynamic> toJson();

  // Helper methods that can be used by all entities
  @protected
  static DateTime? parseDateTime(dynamic value) {
    if (value == null) return null;
    if (value is DateTime) return value;
    if (value is String) {
      try {
        return DateTime.parse(value);
      } catch (_) {
        try {
          return DateTime.fromMillisecondsSinceEpoch(int.parse(value));
        } catch (_) {
          return null;
        }
      }
    }
    return null;
  }

  @protected
  static List<String> parseTags(dynamic value) {
    if (value == null) return [];
    if (value is List) {
      return value.map((e) => e.toString()).toList();
    }
    if (value is String) return [value];
    return [];
  }
}

================
File: features/chat/domain/models/entity_factory.dart
================
import 'entity_base.dart';
import 'task_entity.dart';
import 'topic_entity.dart';
import 'note_entity.dart';
import 'person_entity.dart';

class EntityFactory {
  static EntityBase fromJson(Map<String, dynamic> json) {
    final type = _parseEntityType(json['type']);

    switch (type) {
      case EntityType.task:
        return TaskEntity.fromJson(json);
      case EntityType.topic:
        return TopicEntity.fromJson(json);
      case EntityType.note:
        return NoteEntity.fromJson(json);
      case EntityType.person:
        return PersonEntity.fromJson(json);
    }
  }

  static EntityType _parseEntityType(String? type) {
    return EntityType.values.firstWhere(
      (e) => e.name.toLowerCase() == (type ?? '').toLowerCase(),
      orElse: () => EntityType.task,
    );
  }
}

================
File: features/chat/domain/models/message.dart
================
// lib/features/chat/domain/models/message.dart

import 'entity.dart';

enum MessageType { text, entity, system }

class Message {
  final String id;
  final String content;
  final MessageType type;
  final List<Entity> entities;
  final DateTime timestamp;
  final Map<String, dynamic>? tokenUsage;
  final String? threadId;
  final bool isThreadComplete;
  final Map<String, int> updatedEntities;
  final String? newPrompt;

  const Message({
    required this.id,
    required this.content,
    this.type = MessageType.text,
    this.entities = const [],
    required this.timestamp,
    this.tokenUsage,
    this.threadId,
    this.isThreadComplete = false,
    this.updatedEntities = const {},
    this.newPrompt,
  });

  factory Message.fromJson(Map<String, dynamic> json) {
    try {
      // Generate a unique message ID if none provided
      final id = json['id']?.toString() ??
          DateTime.now().microsecondsSinceEpoch.toString();

      // Use 'response' field as content, falling back to 'content' if not present
      final content =
          json['response']?.toString() ?? json['content']?.toString() ?? '';

      // Parse entities from the new structure
      final entities = <Entity>[];
      if (json['entities'] is Map<String, dynamic>) {
        final entitiesMap = json['entities'] as Map<String, dynamic>;

        // Process tasks
        if (entitiesMap['tasks'] is List) {
          for (final task in entitiesMap['tasks']) {
            try {
              if (task is Map<String, dynamic>) {
                entities.add(Entity(
                  id: task['task_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.task,
                  title: task['title']?.toString() ?? 'Untitled Task',
                  data: Map<String, dynamic>.from(task),
                  timestamp:
                      DateTime.tryParse(task['created_at']?.toString() ?? '') ??
                          DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing task: $e');
            }
          }
        }

        // Process notes
        if (entitiesMap['notes'] is List) {
          for (final note in entitiesMap['notes']) {
            try {
              if (note is Map<String, dynamic>) {
                entities.add(Entity(
                  id: note['note_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.note,
                  title: note['content']?.toString() ?? 'Untitled Note',
                  data: Map<String, dynamic>.from(note),
                  timestamp:
                      DateTime.tryParse(note['created_at']?.toString() ?? '') ??
                          DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing note: $e');
            }
          }
        }

        // Process people
        if (entitiesMap['people'] is List) {
          for (final person in entitiesMap['people']) {
            try {
              if (person is Map<String, dynamic>) {
                entities.add(Entity(
                  id: person['person_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.person,
                  title: person['name']?.toString() ??
                      person['screen_name']?.toString() ??
                      'Unnamed Person',
                  data: Map<String, dynamic>.from(person),
                  timestamp: DateTime.tryParse(
                          person['created_at']?.toString() ?? '') ??
                      DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing person: $e');
            }
          }
        }

        // Process topics
        if (entitiesMap['topics'] is List) {
          for (final topic in entitiesMap['topics']) {
            try {
              if (topic is Map<String, dynamic>) {
                entities.add(Entity(
                  id: topic['topic_id']?.toString() ??
                      DateTime.now().microsecondsSinceEpoch.toString(),
                  type: EntityType.topic,
                  title: topic['name']?.toString() ?? 'Untitled Topic',
                  data: Map<String, dynamic>.from(topic),
                  timestamp: DateTime.tryParse(
                          topic['created_at']?.toString() ?? '') ??
                      DateTime.now(),
                ));
              }
            } catch (e) {
              print('Error parsing topic: $e');
            }
          }
        }
      }

      // Parse token usage safely
      Map<String, dynamic>? tokenUsage;
      if (json['token_usage'] is Map) {
        tokenUsage = Map<String, dynamic>.from(json['token_usage'] as Map);
      }

      // Parse updated entities safely
      final updatedEntities = <String, int>{};
      if (json['updated_entities'] is Map) {
        final updateMap = json['updated_entities'] as Map;
        for (final entry in updateMap.entries) {
          try {
            updatedEntities[entry.key.toString()] =
                int.tryParse(entry.value.toString()) ?? 0;
          } catch (e) {
            print('Error parsing updated entity count: $e');
          }
        }
      }

      return Message(
        id: id,
        content: content,
        type: MessageType.values.firstWhere(
          (t) => t.name == (json['type'] as String?)?.toLowerCase(),
          orElse: () => MessageType.text,
        ),
        entities: entities,
        timestamp: DateTime.tryParse(json['timestamp']?.toString() ?? '') ??
            DateTime.now(),
        tokenUsage: tokenUsage,
        threadId: json['thread_id']?.toString(),
        isThreadComplete: json['is_thread_complete'] as bool? ?? false,
        updatedEntities: updatedEntities,
        newPrompt: json['new_prompt']?.toString(),
      );
    } catch (e, stackTrace) {
      print('Error parsing Message: $e');
      print('Stack trace: $stackTrace');

      // Return a default error message if parsing fails
      return Message(
        id: DateTime.now().microsecondsSinceEpoch.toString(),
        content: 'Error parsing message: $e',
        type: MessageType.system,
        timestamp: DateTime.now(),
        isThreadComplete: false,
      );
    }
  }

  Map<String, dynamic> toJson() {
    try {
      return {
        'id': id,
        'content': content,
        'type': type.name,
        'entities': entities.map((e) => e.toJson()).toList(),
        'timestamp': timestamp.toIso8601String(),
        if (tokenUsage != null) 'token_usage': tokenUsage,
        if (threadId != null) 'thread_id': threadId,
        'is_thread_complete': isThreadComplete,
        'updated_entities': updatedEntities,
        if (newPrompt != null) 'new_prompt': newPrompt,
      };
    } catch (e) {
      print('Error converting Message to JSON: $e');
      return {
        'id': id,
        'content': content,
        'type': type.name,
        'timestamp': timestamp.toIso8601String(),
        'is_thread_complete': isThreadComplete,
      };
    }
  }

  Message copyWith({
    String? id,
    String? content,
    MessageType? type,
    List<Entity>? entities,
    DateTime? timestamp,
    Map<String, dynamic>? tokenUsage,
    String? threadId,
    bool? isThreadComplete,
    Map<String, int>? updatedEntities,
    String? newPrompt,
  }) {
    return Message(
      id: id ?? this.id,
      content: content ?? this.content,
      type: type ?? this.type,
      entities: entities ?? this.entities,
      timestamp: timestamp ?? this.timestamp,
      tokenUsage: tokenUsage ?? this.tokenUsage,
      threadId: threadId ?? this.threadId,
      isThreadComplete: isThreadComplete ?? this.isThreadComplete,
      updatedEntities: updatedEntities ?? this.updatedEntities,
      newPrompt: newPrompt ?? this.newPrompt,
    );
  }
}

================
File: features/chat/domain/models/note_entity.dart
================
import 'entity_base.dart';

class NoteEntity extends EntityBase {
  final String noteId;
  final String content;
  final String createdAt;
  final String updatedAt;
  final List<String> relatedPeople;
  final List<String> relatedTasks;
  final List<String> relatedTopics;

  NoteEntity({
    required this.noteId,
    required this.content,
    required this.createdAt,
    required this.updatedAt,
    required this.relatedPeople,
    required this.relatedTasks,
    required this.relatedTopics,
    required super.id,
    required super.timestamp,
    super.tags = const [],
  }) : super(
          type: EntityType.note,
          title: content.split('\n').first, // Use first line as title
        );

  factory NoteEntity.fromJson(Map<String, dynamic> json) {
    return NoteEntity(
      id: json['id'] ?? '',
      noteId: json['noteId'] ?? '',
      content: json['content'] ?? '',
      createdAt: json['createdAt'] ?? '',
      updatedAt: json['updatedAt'] ?? '',
      relatedPeople: List<String>.from(json['relatedPeople'] ?? []),
      relatedTasks: List<String>.from(json['relatedTasks'] ?? []),
      relatedTopics: List<String>.from(json['relatedTopics'] ?? []),
      timestamp: EntityBase.parseDateTime(json['timestamp']) ?? DateTime.now(),
      tags: EntityBase.parseTags(json['tags']),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    return {
      'id': super.id,
      'noteId': noteId,
      'content': content,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'relatedPeople': relatedPeople,
      'relatedTasks': relatedTasks,
      'relatedTopics': relatedTopics,
      'timestamp': super.timestamp.toIso8601String(),
      'tags': super.tags,
      'type': super.type.name,
    };
  }
}

================
File: features/chat/domain/models/person_entity.dart
================
import 'entity_base.dart';

class PersonEntity extends EntityBase {
  final String personId;
  final String name;
  final String? designation;
  final String? relationType;
  final String? importance;
  final String? notes;
  final Map<String, String>? contact;

  PersonEntity({
    required this.personId,
    required this.name,
    this.designation,
    this.relationType,
    this.importance,
    this.notes,
    this.contact,
    required super.id,
    required super.timestamp,
    super.tags = const [],
  }) : super(
          type: EntityType.person,
          title: name,
        );

  factory PersonEntity.fromJson(Map<String, dynamic> json) {
    return PersonEntity(
      id: json['id'] ?? '',
      personId: json['personId'] ?? '',
      name: json['name'] ?? '',
      designation: json['designation'],
      relationType: json['relationType'],
      importance: json['importance'],
      notes: json['notes'],
      contact: json['contact'] != null
          ? Map<String, String>.from(json['contact'])
          : null,
      timestamp: EntityBase.parseDateTime(json['timestamp']) ?? DateTime.now(),
      tags: EntityBase.parseTags(json['tags']),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    return {
      'id': super.id,
      'personId': personId,
      'name': name,
      'designation': designation,
      'relationType': relationType,
      'importance': importance,
      'notes': notes,
      'contact': contact,
      'timestamp': super.timestamp.toIso8601String(),
      'tags': super.tags,
      'type': super.type.name,
    };
  }
}

================
File: features/chat/domain/models/task_entity.dart
================
import 'entity_base.dart';

class TaskEntity extends EntityBase {
  final String taskId;
  final String taskType;
  final String description;
  final String status;
  final List<String> actions;
  final Map<String, dynamic> people;
  final List<String> dependencies;
  final String schedule;
  final String priority;

  TaskEntity({
    required this.taskId,
    required this.taskType,
    required this.description,
    required this.status,
    required this.actions,
    required this.people,
    required this.dependencies,
    required this.schedule,
    required this.priority,
    required super.id,
    required super.timestamp,
    super.tags = const [],
  }) : super(
          type: EntityType.task,
          title: description,
        );

  factory TaskEntity.fromJson(Map<String, dynamic> json) {
    return TaskEntity(
      id: json['id'] ?? '',
      taskId: json['taskId'] ?? '',
      taskType: json['type'] ?? '',
      description: json['description'] ?? '',
      status: json['status'] ?? '',
      actions: List<String>.from(json['actions'] ?? []),
      people: Map<String, dynamic>.from(json['people'] ?? {}),
      dependencies: List<String>.from(json['dependencies'] ?? []),
      schedule: json['schedule'] ?? '',
      priority: json['priority'] ?? '',
      timestamp: EntityBase.parseDateTime(json['timestamp']) ?? DateTime.now(),
      tags: EntityBase.parseTags(json['tags']),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    return {
      'id': super.id,
      'taskId': taskId,
      'type': taskType,
      'description': description,
      'status': status,
      'actions': actions,
      'people': people,
      'dependencies': dependencies,
      'schedule': schedule,
      'priority': priority,
      'timestamp': super.timestamp.toIso8601String(),
      'tags': super.tags,
    };
  }
}

================
File: features/chat/domain/models/topic_entity.dart
================
import 'entity_base.dart';

class TopicEntity extends EntityBase {
  final String topicId;
  final String name;
  final String description;
  final List<String> keywords;
  final List<String> relatedPeople;
  final List<String> relatedTasks;

  TopicEntity({
    required this.topicId,
    required this.name,
    required this.description,
    required this.keywords,
    required this.relatedPeople,
    required this.relatedTasks,
    required super.id,
    required super.timestamp,
    super.tags = const [],
  }) : super(
          type: EntityType.topic,
          title: name,
        );

  factory TopicEntity.fromJson(Map<String, dynamic> json) {
    return TopicEntity(
      id: json['id'] ?? '',
      topicId: json['topicId'] ?? '',
      name: json['name'] ?? '',
      description: json['description'] ?? '',
      keywords: List<String>.from(json['keywords'] ?? []),
      relatedPeople: List<String>.from(json['relatedPeople'] ?? []),
      relatedTasks: List<String>.from(json['relatedTasks'] ?? []),
      timestamp: EntityBase.parseDateTime(json['timestamp']) ?? DateTime.now(),
      tags: EntityBase.parseTags(json['tags']),
    );
  }

  @override
  Map<String, dynamic> toJson() {
    return {
      'id': super.id,
      'topicId': topicId,
      'name': name,
      'description': description,
      'keywords': keywords,
      'relatedPeople': relatedPeople,
      'relatedTasks': relatedTasks,
      'timestamp': super.timestamp.toIso8601String(),
      'tags': super.tags,
      'type': super.type.name,
    };
  }
}

================
File: features/chat/data/chat_service.dart
================
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../domain/models/message.dart';

class ChatService {
  final ApiClient _apiClient;

  ChatService(this._apiClient);

  Future<Message> sendMessage(String input, {String? threadId}) async {
    try {
      final response = await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/ask',
        data: {
          'user_input': input,
          if (threadId != null) 'thread_id': threadId,
        },
      );

      return Message.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Message>> getThread(String threadId) async {
    try {
      final response = await _apiClient.get(
        '${AppConfig.sidekickEndpoint}/conversation/$threadId',
      );

      return (response.data as List)
          .map((json) => Message.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      rethrow;
    }
  }
}

================
File: features/chat/widgets/entity/base_entity_card.dart
================
import 'package:flutter/material.dart';

abstract class BaseEntityCard extends StatelessWidget {
  final VoidCallback? onTap;

  const BaseEntityCard({
    super.key,
    this.onTap,
  });

  @protected
  Widget buildIcon();

  @protected
  String getTypeText();

  @protected
  Widget buildContent();

  @protected
  Widget? buildBottomRow() => null;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 332,
        height: 140,
        decoration: ShapeDecoration(
          color: Colors.transparent,
          shape: RoundedRectangleBorder(
            side: const BorderSide(width: 1, color: Colors.white),
            borderRadius: BorderRadius.circular(20),
          ),
        ),
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header with icon and type
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    buildIcon(),
                    const SizedBox(width: 8),
                    Text(
                      getTypeText(),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 18,
                        fontFamily: 'Graphik',
                        fontWeight: FontWeight.w400,
                      ),
                    ),
                  ],
                ),
                Transform.rotate(
                  angle: -0.79,
                  child: const Icon(
                    Icons.arrow_forward,
                    color: Colors.white,
                    size: 24,
                  ),
                ),
              ],
            ),

            const Spacer(),

            // Content
            buildContent(),

            const Spacer(),

            // Bottom Row (if any)
            if (buildBottomRow() != null) buildBottomRow()!,
          ],
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/entity/entity_card_factory.dart
================
import 'package:flutter/material.dart';
import '../../domain/models/entity_base.dart';
import '../../domain/models/task_entity.dart';
import '../../domain/models/topic_entity.dart';
import '../../domain/models/note_entity.dart';
import '../../domain/models/person_entity.dart';
import 'task_card.dart';
import 'topic_card.dart';
import 'note_card.dart';
import 'person_card.dart';

class EntityCardFactory {
  static Widget createCard(EntityBase entity, {VoidCallback? onTap}) {
    switch (entity.type) {
      case EntityType.task:
        return TaskCard(
          task: entity as TaskEntity,
          onTap: onTap,
        );
      case EntityType.topic:
        return TopicCard(
          topic: entity as TopicEntity,
          onTap: onTap,
        );
      case EntityType.note:
        return NoteCard(
          note: entity as NoteEntity,
          onTap: onTap,
        );
      case EntityType.person:
        return PersonCard(
          person: entity as PersonEntity,
          onTap: onTap,
        );
    }
  }
}

================
File: features/chat/widgets/entity/entity_detail_view.dart
================
// lib/features/chat/widgets/entity/entity_detail_view.dart

import 'package:flutter/material.dart';
import '../../domain/models/entity.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../presentation/providers/entity_provider.dart';

class EntityDetailView extends ConsumerWidget {
  final Entity entity;
  final VoidCallback onClose;

  const EntityDetailView({
    super.key,
    required this.entity,
    required this.onClose,
  });

  Future<void> _handleAction(
      BuildContext context, WidgetRef ref, Function action) async {
    try {
      ref.read(entityActionsLoadingProvider.notifier).state = true;
      ref.read(entityActionsErrorProvider.notifier).state = null;

      await action();

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Action completed successfully')),
        );
        onClose();
      }
    } catch (e) {
      ref.read(entityActionsErrorProvider.notifier).state = e.toString();
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString()),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      ref.read(entityActionsLoadingProvider.notifier).state = false;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isLoading = ref.watch(entityActionsLoadingProvider);
    final error = ref.watch(entityActionsErrorProvider);
    final actions = ref.watch(entityActionsProvider);

    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        constraints: const BoxConstraints(maxWidth: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header remains the same...
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: _getColorForType(entity.type).withOpacity(0.1),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  if (isLoading)
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  else
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: onClose,
                      color: Colors.black54,
                    ),
                ],
              ),
            ),

            if (error != null)
              Container(
                padding: const EdgeInsets.all(8),
                color: Colors.red.shade50,
                child: Text(
                  error,
                  style: TextStyle(color: Colors.red.shade700),
                ),
              ),

            // Content section remains the same...
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    entity.title,
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 16),
                  _buildEntityContent(context),
                  const SizedBox(height: 16),
                  if (entity.tags.isNotEmpty) ...[
                    const Divider(),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: entity.tags
                          .map((tag) => Chip(
                                label: Text(tag),
                                backgroundColor: _getColorForType(entity.type)
                                    .withOpacity(0.1),
                                labelStyle: TextStyle(
                                    color: _getColorForType(entity.type)),
                              ))
                          .toList(),
                    ),
                  ],
                ],
              ),
            ),

            // Updated action buttons with loading state
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  // Add type-specific action buttons
                  ...switch (entity.type) {
                    EntityType.task => [
                        TextButton.icon(
                          icon: const Icon(Icons.check_circle_outline),
                          label: const Text('Mark Complete'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.completeTask(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.note => [
                        TextButton.icon(
                          icon: const Icon(Icons.edit),
                          label: const Text('Edit'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.editNote(entity.id,
                                        entity.data['content'] ?? ''),
                                  ),
                        ),
                      ],
                    EntityType.person => [
                        TextButton.icon(
                          icon: const Icon(Icons.person_add),
                          label: const Text('Add to Team'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.addPersonToTeam(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.topic => [
                        TextButton.icon(
                          icon: const Icon(Icons.add_task),
                          label: const Text('Create Task'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () =>
                                        actions.createTaskFromTopic(entity.id),
                                  ),
                        ),
                      ],
                  },
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Utility methods remain the same...
  Color _getColorForType(EntityType type) => switch (type) {
        EntityType.task => Colors.blue,
        EntityType.note => Colors.green,
        EntityType.person => Colors.purple,
        EntityType.topic => Colors.orange,
      };

  IconData _getIconForType(EntityType type) => switch (type) {
        EntityType.task => Icons.task_alt,
        EntityType.note => Icons.note,
        EntityType.person => Icons.person,
        EntityType.topic => Icons.topic,
      };

  // _buildEntityContent remains the same...
  Widget _buildEntityContent(BuildContext context) {
    switch (entity.type) {
      case EntityType.task:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Status: ${entity.data['status'] ?? 'New'}',
              style: Theme.of(context).textTheme.bodyLarge,
            ),
            if (entity.data['due_date'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Due: ${entity.data['due_date']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            const SizedBox(height: 16),
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        );

      case EntityType.note:
        return Text(
          entity.data['content'] ?? '',
          style: Theme.of(context).textTheme.bodyMedium,
        );

      case EntityType.person:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (entity.data['email'] != null)
              Text(
                'Email: ${entity.data['email']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            if (entity.data['role'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Role: ${entity.data['role']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            if (entity.data['notes'] != null) ...[
              const SizedBox(height: 16),
              Text(
                entity.data['notes'],
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ],
          ],
        );

      case EntityType.topic:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if ((entity.data['keywords'] as List?)?.isNotEmpty ?? false) ...[
              const SizedBox(height: 16),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: (entity.data['keywords'] as List)
                    .map((keyword) => Chip(
                          label: Text(keyword),
                          backgroundColor: Colors.grey.shade200,
                        ))
                    .toList(),
              ),
            ],
          ],
        );
    }
  }
}

================
File: features/chat/widgets/entity/note_card.dart
================
import 'package:flutter/material.dart';
import '../../domain/models/note_entity.dart';
import '../../../../core/theme/theme.dart';
import 'base_entity_card.dart';

class NoteCard extends BaseEntityCard {
  final NoteEntity note;

  const NoteCard({
    super.key,
    required this.note,
    super.onTap,
  });

  @override
  Widget buildIcon() {
    return const Icon(
      Icons.note,
      color: Colors.white,
      size: 18,
    );
  }

  @override
  String getTypeText() => 'NOTE';

  @override
  Widget buildContent() {
    return Text(
      note.content,
      style: const TextStyle(
        color: AppColors.green,
        fontSize: 18,
        fontFamily: 'Blacker Display',
        fontWeight: FontWeight.w400,
      ),
      maxLines: 2,
      overflow: TextOverflow.ellipsis,
    );
  }

  @override
  Widget buildBottomRow() {
    final hasRelatedItems = note.relatedPeople.isNotEmpty ||
        note.relatedTasks.isNotEmpty ||
        note.relatedTopics.isNotEmpty;

    if (!hasRelatedItems) {
      return const SizedBox.shrink();
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(
          note.updatedAt,
          style: TextStyle(
            color: Colors.white.withOpacity(0.74),
            fontSize: 14,
            fontFamily: 'Inter',
          ),
        ),
        Text(
          '${note.relatedPeople.length + note.relatedTasks.length + note.relatedTopics.length} LINKS',
          style: TextStyle(
            color: Colors.white.withOpacity(0.74),
            fontSize: 14,
            fontFamily: 'Inter',
          ),
        ),
      ],
    );
  }
}

================
File: features/chat/widgets/entity/person_card.dart
================
import 'package:flutter/material.dart';
import '../../domain/models/person_entity.dart';
import '../../../../core/theme/theme.dart';
import 'base_entity_card.dart';

class PersonCard extends BaseEntityCard {
  final PersonEntity person;

  const PersonCard({
    super.key,
    required this.person,
    super.onTap,
  });

  @override
  Widget buildIcon() {
    return const Icon(
      Icons.person_outline,
      color: Colors.white,
      size: 18,
    );
  }

  @override
  String getTypeText() => 'PERSON';

  @override
  Widget buildContent() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          person.name,
          style: const TextStyle(
            color: AppColors.green,
            fontSize: 18,
            fontFamily: 'Blacker Display',
            fontWeight: FontWeight.w400,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        if (person.designation != null)
          Text(
            person.designation!,
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
            ),
          ),
      ],
    );
  }

  @override
  Widget buildBottomRow() {
    if (person.relationType == null && person.importance == null) {
      return const SizedBox.shrink();
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        if (person.relationType != null)
          Text(
            person.relationType!.toUpperCase(),
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
              fontFamily: 'Inter',
            ),
          ),
        if (person.importance != null) ...[
          const SizedBox(width: 8),
          Text(
            person.importance!.toUpperCase(),
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
              fontFamily: 'Inter',
            ),
          ),
        ],
      ],
    );
  }
}

================
File: features/chat/widgets/entity/task_card.dart
================
import 'package:flutter/material.dart';
import '../../domain/models/task_entity.dart';
import '../../../../core/theme/theme.dart';
import 'base_entity_card.dart';

class TaskCard extends BaseEntityCard {
  final TaskEntity task;

  const TaskCard({
    super.key,
    required this.task,
    super.onTap,
  });

  @override
  Widget buildIcon() {
    return const Icon(
      Icons.check_circle_outline,
      color: Colors.white,
      size: 18,
    );
  }

  @override
  String getTypeText() => 'TASK';

  @override
  Widget buildContent() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          task.description,
          style: const TextStyle(
            color: AppColors.green,
            fontSize: 18,
            fontFamily: 'Blacker Display',
            fontWeight: FontWeight.w400,
          ),
          maxLines: 2,
          overflow: TextOverflow.ellipsis,
        ),
        if (task.schedule.isNotEmpty)
          Text(
            task.schedule,
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
            ),
          ),
      ],
    );
  }

  @override
  Widget buildBottomRow() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        if (task.priority.isNotEmpty)
          Text(
            task.priority.toUpperCase(),
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
              fontFamily: 'Inter',
            ),
          ),
        if (task.status.isNotEmpty) ...[
          const SizedBox(width: 8),
          Text(
            task.status.toUpperCase(),
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
              fontFamily: 'Inter',
            ),
          ),
        ],
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 332,
        height: 212,
        decoration: ShapeDecoration(
          color: Colors.transparent,
          shape: RoundedRectangleBorder(
            side: const BorderSide(width: 1, color: Colors.white),
            borderRadius: BorderRadius.circular(20),
          ),
        ),
        child: Stack(
          children: [
            // Main Content
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Header
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Row(
                        children: [
                          buildIcon(),
                          const SizedBox(width: 8),
                          Text(
                            getTypeText(),
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 14,
                              fontFamily: 'Graphik',
                              fontWeight: FontWeight.w400,
                            ),
                          ),
                        ],
                      ),
                      Transform.rotate(
                        angle: -0.79,
                        child: const Icon(
                          Icons.arrow_forward,
                          color: Colors.white,
                          size: 24,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),

                  // Task Description
                  Text(
                    task.description,
                    style: const TextStyle(
                      color: AppColors.green,
                      fontSize: 18,
                      fontFamily: 'Blacker Display',
                      fontWeight: FontWeight.w400,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 24),

                  // Status and Priority
                  Row(
                    children: [
                      if (task.priority.isNotEmpty)
                        Text(
                          task.priority.toUpperCase(),
                          style: TextStyle(
                            color: Colors.white.withOpacity(0.74),
                            fontSize: 14,
                            fontFamily: 'Inter',
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      if (task.priority.isNotEmpty && task.status.isNotEmpty)
                        const SizedBox(width: 42),
                      if (task.status.isNotEmpty)
                        Text(
                          task.status.toUpperCase(),
                          style: TextStyle(
                            color: Colors.white.withOpacity(0.74),
                            fontSize: 14,
                            fontFamily: 'Inter',
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                    ],
                  ),
                ],
              ),
            ),

            // Bottom Section with Divider and Due Date
            Positioned(
              left: 0,
              right: 0,
              bottom: 0,
              child: Column(
                children: [
                  // Divider
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 20),
                    child: Container(
                      height: 0.5,
                      color: Colors.white,
                    ),
                  ),

                  // Due Date and People Count
                  Padding(
                    padding: const EdgeInsets.fromLTRB(24, 16, 24, 16),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        // Due Date
                        if (task.schedule.isNotEmpty)
                          Text(
                            _formatSchedule(task.schedule),
                            style: TextStyle(
                              color: Colors.white.withOpacity(0.74),
                              fontSize: 14,
                              fontFamily: 'Graphik',
                              fontWeight: FontWeight.w400,
                            ),
                          ),

                        // People Count
                        if (task.people.isNotEmpty)
                          Container(
                            width: 24,
                            height: 24,
                            decoration: const BoxDecoration(
                              shape: BoxShape.circle,
                              color: AppColors.green,
                            ),
                            child: Center(
                              child: Text(
                                task.people.length.toString(),
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 12,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatSchedule(String schedule) {
    // TODO: Implement proper schedule formatting
    return 'due in a day';
  }
}

================
File: features/chat/widgets/entity/topic_card.dart
================
import 'package:flutter/material.dart';
import '../../domain/models/topic_entity.dart';
import '../../../../core/theme/theme.dart';
import 'base_entity_card.dart';

class TopicCard extends BaseEntityCard {
  final TopicEntity topic;

  const TopicCard({
    super.key,
    required this.topic,
    super.onTap,
  });

  @override
  Widget buildIcon() {
    return const Icon(
      Icons.topic,
      color: Colors.white,
      size: 18,
    );
  }

  @override
  String getTypeText() => 'TOPIC';

  @override
  Widget buildContent() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          topic.name,
          style: const TextStyle(
            color: AppColors.green,
            fontSize: 18,
            fontFamily: 'Blacker Display',
            fontWeight: FontWeight.w400,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        if (topic.description.isNotEmpty)
          Text(
            topic.description,
            style: TextStyle(
              color: Colors.white.withOpacity(0.74),
              fontSize: 14,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
      ],
    );
  }

  @override
  Widget buildBottomRow() {
    if (topic.keywords.isEmpty) {
      return const SizedBox.shrink();
    }

    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        Text(
          topic.keywords.take(2).join(', ').toUpperCase(),
          style: TextStyle(
            color: Colors.white.withOpacity(0.74),
            fontSize: 14,
            fontFamily: 'Inter',
          ),
        ),
      ],
    );
  }
}

================
File: features/chat/presentation/providers/chat_provider.dart
================
// lib/features/chat/presentation/providers/chat_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/chat_service.dart';
import '../../domain/models/message.dart';
import '../../../../core/providers/core_providers.dart';
import '../../domain/models/entity_base.dart';
import '../../domain/models/entity_factory.dart';

// Export ChatState for use in other files
export '../../domain/models/message.dart';

// Service provider
final chatServiceProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ChatService(apiClient);
});

class ChatMessage {
  final String content;
  final bool isUserMessage;
  final bool isThreadComplete;
  final DateTime timestamp;
  final String? threadId;
  final bool isError;
  final List<EntityBase> entities;
  final Map<String, dynamic>? tokenUsage;

  ChatMessage({
    required this.content,
    required this.isUserMessage,
    this.isThreadComplete = false,
    DateTime? timestamp,
    this.threadId,
    this.isError = false,
    this.entities = const [],
    this.tokenUsage,
  }) : timestamp = timestamp ?? DateTime.now();

  ChatMessage copyWith({
    String? content,
    bool? isUserMessage,
    bool? isThreadComplete,
    DateTime? timestamp,
    String? threadId,
    bool? isError,
    List<EntityBase>? entities,
    Map<String, dynamic>? tokenUsage,
  }) {
    return ChatMessage(
      content: content ?? this.content,
      isUserMessage: isUserMessage ?? this.isUserMessage,
      isThreadComplete: isThreadComplete ?? this.isThreadComplete,
      timestamp: timestamp ?? this.timestamp,
      threadId: threadId ?? this.threadId,
      isError: isError ?? this.isError,
      entities: entities ?? this.entities,
      tokenUsage: tokenUsage ?? this.tokenUsage,
    );
  }

  factory ChatMessage.fromMessage(Message message) {
    return ChatMessage(
      content: message.content,
      isUserMessage: false,
      threadId: message.threadId,
      isThreadComplete: message.isThreadComplete,
      entities: message.entities
          .map((e) => EntityFactory.fromJson(e.toJson()))
          .toList(),
      tokenUsage: message.tokenUsage,
      timestamp: message.timestamp,
    );
  }
}

class ChatState {
  final List<ChatMessage> messages;
  final bool isLoading;
  final String? error;
  final String? currentThreadId;
  final Message? messageBeingRetried;

  const ChatState({
    this.messages = const [],
    this.isLoading = false,
    this.error,
    this.currentThreadId,
    this.messageBeingRetried,
  });

  ChatState copyWith({
    List<ChatMessage>? messages,
    bool? isLoading,
    String? error,
    String? currentThreadId,
    Message? messageBeingRetried,
  }) {
    return ChatState(
      messages: messages ?? this.messages,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      currentThreadId: currentThreadId ?? this.currentThreadId,
      messageBeingRetried: messageBeingRetried ?? this.messageBeingRetried,
    );
  }
}

class ChatNotifier extends StateNotifier<ChatState> {
  final ChatService _chatService;

  ChatNotifier(this._chatService) : super(const ChatState());

  Future<void> sendMessage(String message) async {
    state = state.copyWith(
      messages: [
        ...state.messages,
        ChatMessage(content: message, isUserMessage: true),
      ],
      isLoading: true,
      error: null,
    );

    try {
      final response = await _chatService.sendMessage(
        message,
        threadId: state.currentThreadId,
      );

      state = state.copyWith(
        messages: [
          ...state.messages,
          ChatMessage.fromMessage(response),
        ],
        currentThreadId: response.threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
        messages: [
          ...state.messages,
          ChatMessage(
            content: 'Error: ${e.toString()}',
            isUserMessage: false,
            isError: true,
          ),
        ],
      );
    }
  }

  Future<void> retryMessage(Message message) async {
    state = state.copyWith(messageBeingRetried: message);
    await sendMessage(message.content);
    state = state.copyWith(messageBeingRetried: null);
  }

  Future<void> loadThread(String threadId) async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      final messages = await _chatService.getThread(threadId);

      final chatMessages =
          messages.map((msg) => ChatMessage.fromMessage(msg)).toList();

      state = state.copyWith(
        messages: chatMessages,
        currentThreadId: threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void clearThread() {
    state = const ChatState();
  }
}

// Export the provider for use in other files
final chatProvider = StateNotifierProvider<ChatNotifier, ChatState>((ref) {
  final chatService = ref.watch(chatServiceProvider);
  return ChatNotifier(chatService);
});

================
File: features/chat/presentation/providers/entity_provider.dart
================
// lib/features/chat/presentation/providers/entity_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/entity.dart';
import '../../../../core/providers/core_providers.dart';
import '../../../../core/config/app_config.dart';
import '../../../../core/network/api_client.dart';

// State provider for tracking the currently selected entity
final selectedEntityProvider = StateProvider<Entity?>((ref) => null);

// Action states
final entityActionsLoadingProvider = StateProvider<bool>((ref) => false);
final entityActionsErrorProvider = StateProvider<String?>((ref) => null);

// Entity actions provider with API client
final entityActionsProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return EntityActions(apiClient);
});

class EntityActions {
  final ApiClient _apiClient;

  EntityActions(this._apiClient);

  Future<void> completeTask(String taskId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/tasks/$taskId/complete',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> editNote(String noteId, String content) async {
    try {
      await _apiClient.put(
        '${AppConfig.sidekickEndpoint}/notes/$noteId',
        data: {'content': content},
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> addPersonToTeam(String personId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/people/$personId/team',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> createTaskFromTopic(String topicId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/topics/$topicId/task',
      );
    } catch (e) {
      rethrow;
    }
  }
}
