================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-25T11:10:59.919Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
core/
  config/
    app_config.dart
  errors/
    exceptions.dart
  network/
    api_client.dart
  providers/
    core_providers.dart
  storage/
    session_storage.dart
features/
  auth/
    data/
      session_manager.dart
    domain/
      user.dart
    presentation/
      providers/
        auth_provider.dart
  chat/
    data/
      chat_service.dart
    domain/
      models/
        entity.dart
        message.dart
    presentation/
      providers/
        chat_provider.dart
        entity_provider.dart
      chat_screen.dart
      splash_screen.dart
    widgets/
      entity/
        entity_card.dart
        entity_detail_view.dart
      message_bubble.dart
      message_list.dart
      search_input.dart
shared/
  widgets/
    app_button.dart
main.dart

================================================================
Repository Files
================================================================

================
File: main.dart
================
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'core/storage/session_storage.dart';
import 'core/network/api_client.dart';
import 'features/chat/presentation/chat_screen.dart';
import 'features/auth/presentation/providers/auth_provider.dart';
import 'features/chat/presentation/splash_screen.dart';
import 'core/providers/core_providers.dart';

void main() async {
  try {
    // Ensure Flutter bindings are initialized
    WidgetsFlutterBinding.ensureInitialized();

    // Initialize Hive
    await Hive.initFlutter();

    // Initialize session storage
    final sessionStorage = SessionStorage();
    await sessionStorage.init();

    // Initialize API client
    final apiClient = ApiClient();

    // Run app with providers
    runApp(
      ProviderScope(
        overrides: [
          // Override the API client provider with our initialized instance
          apiClientProvider.overrideWithValue(apiClient),
          // Override the session storage provider with our initialized instance
          sessionStorageProvider.overrideWithValue(sessionStorage),
        ],
        child: const FlywallApp(),
      ),
    );
  } catch (e, stackTrace) {
    debugPrint('Error during app initialization: $e');
    debugPrint('Stack trace: $stackTrace');

    // Show error UI if initialization fails
    runApp(
      MaterialApp(
        home: Scaffold(
          body: Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    color: Colors.red,
                    size: 48,
                  ),
                  const SizedBox(height: 16),
                  const Text(
                    'Failed to initialize app',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    e.toString(),
                    textAlign: TextAlign.center,
                    style: const TextStyle(color: Colors.red),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class FlywallApp extends ConsumerWidget {
  const FlywallApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);

    return MaterialApp(
      title: 'Flywall',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: authState.status == AuthStatus.authenticated
          ? const ChatScreen()
          : const SplashScreen(),
    );
  }
}

================
File: core/config/app_config.dart
================
// lib/core/config/app_config.dart
class AppConfig {
  static const bool useLocalHost = false; // Set to false for production

  // API Configuration
  static String get baseUrl => useLocalHost
      ? 'http://10.0.2.2:8000' // Android emulator localhost
      : 'https://fapi.nyn.sh'; // Production API

  static const String apiVersion = 'v1';
  static String get apiPath => '/api/$apiVersion';

  // API Endpoints
  static String get authEndpoint => '$baseUrl/auth';
  static String get tokenEndpoint => '$authEndpoint/token';
  static String get registerEndpoint => '$authEndpoint/register';
  static String get userEndpoint => '$authEndpoint/users/me';
  static String get sidekickEndpoint => '$baseUrl$apiPath/sidekick';

  // WebSocket Configuration
  static String get wsUrl =>
      useLocalHost ? 'ws://10.0.2.2:8000/ws' : 'wss://fapi.nyn.sh/ws';

  // Storage keys
  static const String sessionBoxName = 'flywall_session';
  static const String userSecretKey = 'user_secret';
  static const String threadIdKey = 'thread_id';

  // Timeouts
  static const Duration connectionTimeout = Duration(seconds: 30);
  static const Duration receiveTimeout = Duration(seconds: 30);

  // Error Messages
  static const String networkErrorMessage =
      'Unable to connect to the server. Please check your internet connection.';
  static const String serverErrorMessage =
      'Something went wrong on our end. Please try again later.';
  static const String authErrorMessage =
      'Authentication failed. Please try again.';
}

================
File: core/errors/exceptions.dart
================
abstract class AppException implements Exception {
  const AppException(this.message);
  final String message;
}

class AuthException extends AppException {
  const AuthException(super.message);
}

class NetworkException extends AppException {
  const NetworkException(super.message);
}

class StorageException extends AppException {
  const StorageException(super.message);
}

================
File: core/storage/session_storage.dart
================
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../config/app_config.dart';

class SessionStorage {
  late Box _box;

  Future<void> init() async {
    _box = await Hive.openBox(AppConfig.sessionBoxName);
    debugPrint('Session storage initialized: ${hasSession()}');
  }

  Future<void> saveUserSecret(String secret) async {
    await _box.put(AppConfig.userSecretKey, secret);
    debugPrint('User secret saved: $secret');
  }

  Future<void> saveThreadId(String? threadId) async {
    if (threadId != null) {
      await _box.put(AppConfig.threadIdKey, threadId);
      debugPrint('Thread ID saved: $threadId');
    } else {
      await _box.delete(AppConfig.threadIdKey);
      debugPrint('Thread ID cleared');
    }
  }

  Future<String?> getUserSecret() async {
    final secret = _box.get(AppConfig.userSecretKey) as String?;
    debugPrint('Retrieved user secret: $secret');
    return secret;
  }

  Future<String?> getThreadId() async {
    final threadId = _box.get(AppConfig.threadIdKey) as String?;
    debugPrint('Retrieved thread ID: $threadId');
    return threadId;
  }

  Future<void> clearSession() async {
    await _box.clear();
    debugPrint('Session cleared');
  }

  bool hasSession() {
    final hasSecret = _box.containsKey(AppConfig.userSecretKey);
    debugPrint('Has session: $hasSecret');
    return hasSecret;
  }
}

================
File: core/providers/core_providers.dart
================
// lib/core/providers/core_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../network/api_client.dart';
import '../storage/session_storage.dart';

/// Core API client provider
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient());

/// Session storage provider
final sessionStorageProvider =
    Provider<SessionStorage>((ref) => SessionStorage());

================
File: core/network/api_client.dart
================
// lib/core/network/api_client.dart
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../errors/exceptions.dart';

class ApiClient {
  late final Dio _dio;

  ApiClient() {
    _dio = Dio(BaseOptions(
      connectTimeout: AppConfig.connectionTimeout,
      receiveTimeout: AppConfig.receiveTimeout,
      validateStatus: (status) => status != null && status < 500,
    ));

    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        return handler.next(options);
      },
      onResponse: (response, handler) {
        return handler.next(response);
      },
      onError: (DioException e, handler) async {
        if (e.type == DioExceptionType.connectionTimeout ||
            e.type == DioExceptionType.receiveTimeout) {
          if (e.requestOptions.extra['retryCount'] == null ||
              e.requestOptions.extra['retryCount'] < 3) {
            final options = e.requestOptions;
            options.extra['retryCount'] =
                (options.extra['retryCount'] ?? 0) + 1;
            return handler.resolve(await _dio.fetch(options));
          }
        }
        return handler.next(e);
      },
    ));
  }

  Future<Response<T>> get<T>(
    String path, {
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.get<T>(
        path,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> post<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.post<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> put<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.put<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  Future<Response<T>> delete<T>(
    String path, {
    dynamic data,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    try {
      return await _dio.delete<T>(
        path,
        data: data,
        queryParameters: queryParameters,
        options: options,
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  AppException _handleError(DioException e) {
    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.receiveTimeout:
      case DioExceptionType.sendTimeout:
        return const NetworkException(AppConfig.networkErrorMessage);

      case DioExceptionType.badResponse:
        if (e.response?.statusCode == 401) {
          return const AuthException(AppConfig.authErrorMessage);
        }
        return NetworkException(
            e.response?.statusMessage ?? AppConfig.serverErrorMessage);

      default:
        return const NetworkException(AppConfig.networkErrorMessage);
    }
  }

  void setAuthToken(String token) {
    _dio.options.headers['Authorization'] = 'Bearer $token';
  }

  void clearAuthToken() {
    _dio.options.headers.remove('Authorization');
  }
}

================
File: shared/widgets/app_button.dart
================
import 'package:flutter/material.dart';

class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isOutlined;

  const AppButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isOutlined = false,
  });

  @override
  Widget build(BuildContext context) {
    final style = isOutlined
        ? OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          )
        : ElevatedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          );

    final child = isLoading
        ? const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(strokeWidth: 2),
          )
        : Text(text);

    return isOutlined
        ? OutlinedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          )
        : ElevatedButton(
            style: style,
            onPressed: isLoading ? null : onPressed,
            child: child,
          );
  }
}

================
File: features/auth/data/session_manager.dart
================
// lib/features/auth/data/session_manager.dart
import 'package:flutter/foundation.dart';
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../../../core/storage/session_storage.dart';
import '../../../core/errors/exceptions.dart';
import '../domain/user.dart';
import 'package:dio/dio.dart';

class SessionManager {
  final ApiClient _apiClient;
  final SessionStorage _storage;
  User? _currentUser;

  SessionManager(this._apiClient, this._storage);

  User? get currentUser => _currentUser;

  Future<bool> login(String userSecret) async {
    try {
      debugPrint('Attempting login with secret: $userSecret');

      // Using form data instead of JSON for the token endpoint
      final response = await _apiClient.post(
        AppConfig.tokenEndpoint,
        data: {'user_secret': userSecret},
        options: Options(
          contentType: Headers.formUrlEncodedContentType,
        ),
      );

      debugPrint('Login response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;

        // Save the access token and user secret
        await _storage.saveUserSecret(userSecret);

        // Store current user with token
        _currentUser = User(
          id: data['user_id'] ?? '',
          screenName: data['screen_name'] ?? '',
          accessToken: data['access_token'],
        );

        // Set the auth token for future requests
        _apiClient.setAuthToken(_currentUser!.accessToken!);

        // Fetch additional user info
        await _fetchUserInfo();

        return true;
      }
      return false;
    } catch (e) {
      debugPrint('Login error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<User> register(String screenName) async {
    try {
      debugPrint('Attempting registration for: $screenName');

      final response = await _apiClient.post(
        AppConfig.registerEndpoint,
        data: {'screen_name': screenName},
      );

      debugPrint('Registration response: ${response.data}');

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        final userSecret = data['user_secret'];

        // Immediately login with the received user_secret
        final loginSuccess = await login(userSecret);
        if (!loginSuccess) {
          throw const AuthException('Login failed after registration');
        }

        return _currentUser!;
      }
      throw const AuthException('Registration failed');
    } catch (e) {
      debugPrint('Registration error: $e');
      throw AuthException(e.toString());
    }
  }

  Future<void> _fetchUserInfo() async {
    try {
      final response = await _apiClient.get(AppConfig.userEndpoint);
      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        _currentUser = _currentUser?.copyWith(
          screenName: data['screen_name'],
          // Add other fields as needed
        );
      }
    } catch (e) {
      debugPrint('Error fetching user info: $e');
    }
  }

  Future<void> logout() async {
    await _storage.clearSession();
    _currentUser = null;
    _apiClient.clearAuthToken();
  }

  Future<bool> restoreSession() async {
    final userSecret = await _storage.getUserSecret();
    debugPrint('Restoring session with secret: $userSecret');
    if (userSecret != null) {
      return login(userSecret);
    }
    return false;
  }
}

================
File: features/auth/domain/user.dart
================
class User {
  final String id;
  final String screenName;
  final String? accessToken;

  const User({
    required this.id,
    required this.screenName,
    this.accessToken,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      screenName: json['screen_name'] as String,
      accessToken: json['access_token'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'screen_name': screenName,
      if (accessToken != null) 'access_token': accessToken,
    };
  }

  User copyWith({
    String? screenName,
  }) {
    return User(
      id: id,
      screenName: screenName ?? this.screenName,
      accessToken: accessToken,
    );
  }
}

================
File: features/chat/data/chat_service.dart
================
import '../../../core/network/api_client.dart';
import '../../../core/config/app_config.dart';
import '../domain/models/message.dart';

class ChatService {
  final ApiClient _apiClient;

  ChatService(this._apiClient);

  Future<Message> sendMessage(String input, {String? threadId}) async {
    try {
      final response = await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/ask',
        data: {
          'user_input': input,
          if (threadId != null) 'thread_id': threadId,
        },
      );

      return Message.fromJson(response.data);
    } catch (e) {
      rethrow;
    }
  }

  Future<List<Message>> getThread(String threadId) async {
    try {
      final response = await _apiClient.get(
        '${AppConfig.sidekickEndpoint}/conversation/$threadId',
      );

      return (response.data as List)
          .map((json) => Message.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      rethrow;
    }
  }
}

================
File: features/chat/presentation/chat_screen.dart
================
// Update lib/features/chat/presentation/chat_screen.dart to include entity state handling

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../widgets/search_input.dart';
import '../widgets/message_list.dart';
import '../widgets/entity/entity_detail_view.dart';
import 'providers/chat_provider.dart';
import 'providers/entity_provider.dart';

class ChatScreen extends ConsumerStatefulWidget {
  const ChatScreen({super.key});

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  final scrollController = ScrollController();

  void _scrollToBottom() {
    if (scrollController.hasClients) {
      scrollController.animateTo(
        scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatState = ref.watch(chatProvider);
    // Add entity state watch if needed
    final selectedEntity = ref.watch(selectedEntityProvider);

    // Listen for changes and scroll to bottom when new messages arrive
    ref.listen<ChatState>(chatProvider, (previous, next) {
      if (previous?.messages.length != next.messages.length) {
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
      }

      if (next.error != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(next.error!),
            backgroundColor: Colors.red,
          ),
        );
      }
    });

    return Scaffold(
      body: SafeArea(
        child: Stack(
          children: [
            Column(
              children: [
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: SearchInput(
                    onSubmitted: (input) {
                      if (input.trim().isNotEmpty) {
                        ref.read(chatProvider.notifier).sendMessage(input);
                      }
                    },
                    enabled: !chatState.isLoading,
                  ),
                ),
                Expanded(
                  child: Stack(
                    children: [
                      MessageList(
                        messages: chatState.messages,
                        scrollController: scrollController,
                      ),
                      if (chatState.isLoading)
                        const Positioned(
                          top: 16,
                          right: 16,
                          child: CircularProgressIndicator(),
                        ),
                    ],
                  ),
                ),
              ],
            ),
            // Add entity detail handling if needed
            if (selectedEntity != null)
              Positioned.fill(
                child: GestureDetector(
                  onTap: () =>
                      ref.read(selectedEntityProvider.notifier).state = null,
                  child: Container(
                    color: Colors.black54,
                    alignment: Alignment.center,
                    child: EntityDetailView(
                      entity: selectedEntity,
                      onClose: () => ref
                          .read(selectedEntityProvider.notifier)
                          .state = null,
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    scrollController.dispose();
    super.dispose();
  }
}

================
File: features/chat/presentation/splash_screen.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../auth/presentation/providers/auth_provider.dart';
import 'chat_screen.dart';
import '../../../../core/providers/core_providers.dart';

class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen> {
  @override
  void initState() {
    super.initState();
    // Schedule the auth check for the next frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _handleAuth();
    });
  }

  Future<void> _handleAuth() async {
    final authNotifier = ref.read(authProvider.notifier);

    try {
      // Get the storage instance
      final storage = ref.read(sessionStorageProvider);

      // Check if we have a session
      if (storage.hasSession()) {
        // Try to restore existing session
        final hasSession = await authNotifier.checkAuth();

        if (!mounted) return;

        if (!hasSession) {
          // If restoration failed, clear session and register new user
          await storage.clearSession();
          await authNotifier.registerAndLogin();
        }
      } else {
        // No existing session, register new user
        await authNotifier.registerAndLogin();
      }
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.toString())),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    ref.listen(authProvider, (previous, next) {
      if (!mounted) return;

      if (next.status == AuthStatus.authenticated) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const ChatScreen()),
        );
      } else if (next.status == AuthStatus.error) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(next.error ?? 'An error occurred')),
        );
      }
    });

    return const Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            FlutterLogo(size: 100),
            SizedBox(height: 24),
            Text(
              'Flywall',
              style: TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: 48),
            CircularProgressIndicator(),
          ],
        ),
      ),
    );
  }
}

================
File: features/chat/widgets/message_bubble.dart
================
// chat/widgets/message_bubble.dart
import 'package:flutter/material.dart';
import '../domain/models/message.dart';

class MessageBubble extends StatelessWidget {
  final Message message;

  const MessageBubble({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: message.type == MessageType.system
            ? Colors.grey.shade200
            : Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            message.content,
            style: Theme.of(context).textTheme.bodyLarge,
          ),
          if (message.tokenUsage != null) ...[
            const SizedBox(height: 8),
            Text(
              'Tokens: ${message.tokenUsage!["total"]}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Colors.grey,
                  ),
            ),
          ],
        ],
      ),
    );
  }
}

================
File: features/chat/widgets/message_list.dart
================
// chat/widgets/message_list.dart
import 'package:flutter/material.dart';
import '../domain/models/message.dart';
import 'message_bubble.dart';
import 'entity/entity_card.dart';

class MessageList extends StatelessWidget {
  final List<Message> messages;
  final ScrollController scrollController;

  const MessageList({
    super.key,
    required this.messages,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: scrollController,
      padding: const EdgeInsets.all(16),
      itemCount: messages.length,
      itemBuilder: (context, index) {
        final message = messages[index];

        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            MessageBubble(message: message),
            if (message.entities.isNotEmpty) ...[
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: message.entities
                    .map((entity) => EntityCard(entity: entity))
                    .toList(),
              ),
            ],
            const SizedBox(height: 16),
          ],
        );
      },
    );
  }
}

================
File: features/chat/widgets/search_input.dart
================
import 'package:flutter/material.dart';

// chat/widgets/search_input.dart
class SearchInput extends StatefulWidget {
  final Function(String) onSubmitted;
  final bool enabled;

  const SearchInput({
    super.key,
    required this.onSubmitted,
    this.enabled = true,
  });

  @override
  State<SearchInput> createState() => _SearchInputState();
}

class _SearchInputState extends State<SearchInput> {
  final controller = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(24),
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: controller,
        enabled: widget.enabled,
        decoration: InputDecoration(
          hintText: widget.enabled ? 'Type something...' : 'Please wait...',
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(24),
            borderSide: BorderSide.none,
          ),
          filled: true,
          fillColor: widget.enabled ? Colors.white : Colors.grey[100],
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 20,
            vertical: 16,
          ),
          prefixIcon: const Icon(Icons.search),
          suffixIcon: widget.enabled && controller.text.isNotEmpty
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () => controller.clear(),
                )
              : null,
        ),
        onSubmitted: (value) {
          if (value.trim().isNotEmpty && widget.enabled) {
            widget.onSubmitted(value);
            controller.clear();
          }
        },
      ),
    );
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }
}

================
File: features/auth/presentation/providers/auth_provider.dart
================
// lib/features/auth/presentation/providers/auth_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/session_manager.dart';
import '../../domain/user.dart';
import '../../../../core/providers/core_providers.dart';

// Session manager provider
final sessionManagerProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  final storage = ref.watch(sessionStorageProvider);
  return SessionManager(apiClient, storage);
});

// Auth state
enum AuthStatus { initial, loading, authenticated, error }

class AuthState {
  final AuthStatus status;
  final User? user;
  final String? error;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.error,
  });

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      error: error,
    );
  }
}

class AuthNotifier extends StateNotifier<AuthState> {
  final SessionManager _sessionManager;

  AuthNotifier(this._sessionManager) : super(const AuthState());

  Future<bool> checkAuth() async {
    try {
      state = state.copyWith(status: AuthStatus.loading);
      final success = await _sessionManager.restoreSession();

      if (success) {
        state = state.copyWith(
          status: AuthStatus.authenticated,
          user: _sessionManager.currentUser,
        );
      } else {
        state = state.copyWith(status: AuthStatus.initial);
      }

      return success;
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
      return false;
    }
  }

  Future<void> registerAndLogin() async {
    try {
      state = state.copyWith(status: AuthStatus.loading);

      final screenName = 'user_${DateTime.now().millisecondsSinceEpoch}';

      // Register and login are now combined in the register method
      final user = await _sessionManager.register(screenName);

      state = state.copyWith(
        status: AuthStatus.authenticated,
        user: user,
      );
    } catch (e) {
      state = state.copyWith(
        status: AuthStatus.error,
        error: e.toString(),
      );
    }
  }

  Future<void> logout() async {
    await _sessionManager.logout();
    state = const AuthState(status: AuthStatus.initial);
  }
}

final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  final sessionManager = ref.watch(sessionManagerProvider);
  return AuthNotifier(sessionManager);
});

================
File: features/chat/domain/models/entity.dart
================
enum EntityType { task, note, person, topic }

class Entity {
  final String id;
  final EntityType type;
  final String title;
  final Map<String, dynamic> data;
  final DateTime timestamp;
  final List<String> tags;

  const Entity({
    required this.id,
    required this.type,
    required this.title,
    required this.data,
    required this.timestamp,
    this.tags = const [],
  });

  factory Entity.fromJson(Map<String, dynamic> json) {
    return Entity(
      id: json['id'] as String,
      type: EntityType.values.firstWhere(
        (e) => e.name == json['type'] as String,
        orElse: () => EntityType.task,
      ),
      title: json['title'] as String,
      data: json['data'] as Map<String, dynamic>,
      timestamp: DateTime.parse(json['timestamp'] as String),
      tags: List<String>.from(json['tags'] ?? []),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'type': type.name,
      'title': title,
      'data': data,
      'timestamp': timestamp.toIso8601String(),
      'tags': tags,
    };
  }
}

================
File: features/chat/domain/models/message.dart
================
// lib/features/chat/domain/models/message.dart

import 'entity.dart';

enum MessageType { text, entity, system }

class Message {
  final String id;
  final String content;
  final MessageType type;
  final List<Entity> entities;
  final DateTime timestamp;
  final Map<String, dynamic>? tokenUsage;
  final String? threadId;
  final bool isThreadComplete;
  final Map<String, int> updatedEntities;
  final String? newPrompt;

  const Message({
    required this.id,
    required this.content,
    this.type = MessageType.text,
    this.entities = const [],
    required this.timestamp,
    this.tokenUsage,
    this.threadId,
    this.isThreadComplete = false,
    this.updatedEntities = const {},
    this.newPrompt,
  });

  factory Message.fromJson(Map<String, dynamic> json) {
    // Generate a unique message ID if none provided
    final id = json['id'] ?? DateTime.now().microsecondsSinceEpoch.toString();

    // Use 'response' field as content, falling back to 'content' if not present
    final content =
        json['response'] as String? ?? json['content'] as String? ?? '';

    // Parse entities if present
    final entities = (json['entities'] as List?)
            ?.map((e) => Entity.fromJson(e as Map<String, dynamic>))
            .toList() ??
        [];

    // Parse token usage
    final tokenUsage = json['token_usage'] as Map<String, dynamic>?;

    // Parse updated entities
    final updatedEntities = (json['updated_entities'] as Map<String, dynamic>?)
            ?.map((key, value) => MapEntry(key, value as int)) ??
        {};

    // Parse thread completion status
    final isThreadComplete = json['is_thread_complete'] as bool? ?? false;

    // Get suggested new prompt if present
    final newPrompt = json['new_prompt'] as String?;

    return Message(
      id: id,
      content: content,
      type: MessageType.values.firstWhere(
        (t) => t.name == (json['type'] as String?),
        orElse: () => MessageType.text,
      ),
      entities: entities,
      timestamp: DateTime.tryParse(json['timestamp'] as String? ?? '') ??
          DateTime.now(),
      tokenUsage: tokenUsage,
      threadId: json['thread_id'] as String?,
      isThreadComplete: isThreadComplete,
      updatedEntities: updatedEntities,
      newPrompt: newPrompt,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'content': content,
      'type': type.name,
      'entities': entities.map((e) => e.toJson()).toList(),
      'timestamp': timestamp.toIso8601String(),
      if (tokenUsage != null) 'token_usage': tokenUsage,
      if (threadId != null) 'thread_id': threadId,
      'is_thread_complete': isThreadComplete,
      'updated_entities': updatedEntities,
      if (newPrompt != null) 'new_prompt': newPrompt,
    };
  }

  Message copyWith({
    String? id,
    String? content,
    MessageType? type,
    List<Entity>? entities,
    DateTime? timestamp,
    Map<String, dynamic>? tokenUsage,
    String? threadId,
    bool? isThreadComplete,
    Map<String, int>? updatedEntities,
    String? newPrompt,
  }) {
    return Message(
      id: id ?? this.id,
      content: content ?? this.content,
      type: type ?? this.type,
      entities: entities ?? this.entities,
      timestamp: timestamp ?? this.timestamp,
      tokenUsage: tokenUsage ?? this.tokenUsage,
      threadId: threadId ?? this.threadId,
      isThreadComplete: isThreadComplete ?? this.isThreadComplete,
      updatedEntities: updatedEntities ?? this.updatedEntities,
      newPrompt: newPrompt ?? this.newPrompt,
    );
  }
}

================
File: features/chat/presentation/providers/chat_provider.dart
================
// lib/features/chat/presentation/providers/chat_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/chat_service.dart';
import '../../domain/models/message.dart';
import '../../../../core/providers/core_providers.dart';

// Export ChatState for use in other files
export '../../domain/models/message.dart';

// Service provider
final chatServiceProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ChatService(apiClient);
});

class ChatState {
  final List<Message> messages;
  final bool isLoading;
  final String? error;
  final String? currentThreadId;
  final Message? messageBeingRetried;

  const ChatState({
    this.messages = const [],
    this.isLoading = false,
    this.error,
    this.currentThreadId,
    this.messageBeingRetried,
  });

  ChatState copyWith({
    List<Message>? messages,
    bool? isLoading,
    String? error,
    String? currentThreadId,
    Message? messageBeingRetried,
  }) {
    return ChatState(
      messages: messages ?? this.messages,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      currentThreadId: currentThreadId ?? this.currentThreadId,
      messageBeingRetried: messageBeingRetried,
    );
  }
}

class ChatNotifier extends StateNotifier<ChatState> {
  final ChatService _chatService;

  ChatNotifier(this._chatService) : super(const ChatState());

  Future<void> sendMessage(String input) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final message = await _chatService.sendMessage(
        input,
        threadId: state.currentThreadId,
      );

      state = state.copyWith(
        messages: [...state.messages, message],
        currentThreadId: message.threadId,
        isLoading: false,
      );

      final isThreadComplete =
          message.tokenUsage?['is_thread_complete'] as bool? ?? false;
      if (isThreadComplete) {
        await Future.delayed(const Duration(seconds: 2));
        clearThread();
      }
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  Future<void> retryMessage(Message message) async {
    state = state.copyWith(messageBeingRetried: message);
    await sendMessage(message.content);
    state = state.copyWith(messageBeingRetried: null);
  }

  Future<void> loadThread(String threadId) async {
    try {
      state = state.copyWith(isLoading: true, error: null);
      final messages = await _chatService.getThread(threadId);
      state = state.copyWith(
        messages: messages,
        currentThreadId: threadId,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void clearThread() {
    state = const ChatState();
  }
}

// Export the provider for use in other files
final chatProvider = StateNotifierProvider<ChatNotifier, ChatState>((ref) {
  final chatService = ref.watch(chatServiceProvider);
  return ChatNotifier(chatService);
});

================
File: features/chat/presentation/providers/entity_provider.dart
================
// lib/features/chat/presentation/providers/entity_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/entity.dart';
import '../../../../core/providers/core_providers.dart';
import '../../../../core/config/app_config.dart';
import '../../../../core/network/api_client.dart';

// State provider for tracking the currently selected entity
final selectedEntityProvider = StateProvider<Entity?>((ref) => null);

// Action states
final entityActionsLoadingProvider = StateProvider<bool>((ref) => false);
final entityActionsErrorProvider = StateProvider<String?>((ref) => null);

// Entity actions provider with API client
final entityActionsProvider = Provider((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return EntityActions(apiClient);
});

class EntityActions {
  final ApiClient _apiClient;

  EntityActions(this._apiClient);

  Future<void> completeTask(String taskId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/tasks/$taskId/complete',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> editNote(String noteId, String content) async {
    try {
      await _apiClient.put(
        '${AppConfig.sidekickEndpoint}/notes/$noteId',
        data: {'content': content},
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> addPersonToTeam(String personId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/people/$personId/team',
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<void> createTaskFromTopic(String topicId) async {
    try {
      await _apiClient.post(
        '${AppConfig.sidekickEndpoint}/topics/$topicId/task',
      );
    } catch (e) {
      rethrow;
    }
  }
}

================
File: features/chat/widgets/entity/entity_card.dart
================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/models/entity.dart';
import 'entity_detail_view.dart';

class EntityCard extends ConsumerWidget {
  final Entity entity;

  const EntityCard({
    super.key,
    required this.entity,
  });

  Color _getColorForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Colors.blue;
      case EntityType.note:
        return Colors.green;
      case EntityType.person:
        return Colors.purple;
      case EntityType.topic:
        return Colors.orange;
    }
  }

  IconData _getIconForType(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Icons.task_alt;
      case EntityType.note:
        return Icons.note;
      case EntityType.person:
        return Icons.person;
      case EntityType.topic:
        return Icons.topic;
    }
  }

  void _showEntityDetail(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => EntityDetailView(
        entity: entity,
        onClose: () => Navigator.of(context).pop(),
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: () => _showEntityDetail(context),
        borderRadius: BorderRadius.circular(12),
        child: Container(
          padding: const EdgeInsets.all(16),
          width: 200,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  // Quick action button based on entity type
                  IconButton(
                    icon: Icon(
                      _getQuickActionIcon(entity.type),
                      size: 20,
                    ),
                    onPressed: () => _handleQuickAction(context),
                    color: _getColorForType(entity.type),
                    tooltip: _getQuickActionTooltip(entity.type),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                entity.title,
                style: Theme.of(context).textTheme.titleMedium,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),
              Text(
                _getPreviewText(entity),
                style: Theme.of(context).textTheme.bodySmall,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              if (entity.tags.isNotEmpty) ...[
                const SizedBox(height: 8),
                SizedBox(
                  height: 24,
                  child: ListView.separated(
                    scrollDirection: Axis.horizontal,
                    itemCount: entity.tags.length,
                    separatorBuilder: (_, __) => const SizedBox(width: 4),
                    itemBuilder: (context, index) => Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: _getColorForType(entity.type).withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        entity.tags[index],
                        style: TextStyle(
                          fontSize: 12,
                          color: _getColorForType(entity.type),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  IconData _getQuickActionIcon(EntityType type) {
    switch (type) {
      case EntityType.task:
        return Icons.check_circle_outline;
      case EntityType.note:
        return Icons.edit;
      case EntityType.person:
        return Icons.person_add;
      case EntityType.topic:
        return Icons.add_task;
    }
  }

  String _getQuickActionTooltip(EntityType type) {
    switch (type) {
      case EntityType.task:
        return 'Mark Complete';
      case EntityType.note:
        return 'Edit Note';
      case EntityType.person:
        return 'Add to Team';
      case EntityType.topic:
        return 'Create Task';
    }
  }

  String _getPreviewText(Entity entity) {
    switch (entity.type) {
      case EntityType.task:
        return 'Status: ${entity.data['status'] ?? 'New'}'
            '${entity.data['due_date'] != null ? ' • Due: ${entity.data['due_date']}' : ''}';
      case EntityType.note:
        return entity.data['content']?.toString() ?? '';
      case EntityType.person:
        return [
          entity.data['role'],
          entity.data['email'],
        ].where((item) => item != null).join(' • ');
      case EntityType.topic:
        return entity.data['description']?.toString() ?? '';
    }
  }

  void _handleQuickAction(BuildContext context) {
    // TODO: Implement quick actions
    switch (entity.type) {
      case EntityType.task:
        // Mark task as complete
        break;
      case EntityType.note:
        // Open note editor
        break;
      case EntityType.person:
        // Add to team
        break;
      case EntityType.topic:
        // Create task from topic
        break;
    }
  }
}

================
File: features/chat/widgets/entity/entity_detail_view.dart
================
// lib/features/chat/widgets/entity/entity_detail_view.dart

import 'package:flutter/material.dart';
import '../../domain/models/entity.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../presentation/providers/entity_provider.dart';

class EntityDetailView extends ConsumerWidget {
  final Entity entity;
  final VoidCallback onClose;

  const EntityDetailView({
    super.key,
    required this.entity,
    required this.onClose,
  });

  Future<void> _handleAction(
      BuildContext context, WidgetRef ref, Function action) async {
    try {
      ref.read(entityActionsLoadingProvider.notifier).state = true;
      ref.read(entityActionsErrorProvider.notifier).state = null;

      await action();

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Action completed successfully')),
        );
        onClose();
      }
    } catch (e) {
      ref.read(entityActionsErrorProvider.notifier).state = e.toString();
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString()),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      ref.read(entityActionsLoadingProvider.notifier).state = false;
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isLoading = ref.watch(entityActionsLoadingProvider);
    final error = ref.watch(entityActionsErrorProvider);
    final actions = ref.watch(entityActionsProvider);

    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        constraints: const BoxConstraints(maxWidth: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header remains the same...
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: _getColorForType(entity.type).withOpacity(0.1),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Icon(
                    _getIconForType(entity.type),
                    color: _getColorForType(entity.type),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    entity.type.name.toUpperCase(),
                    style: TextStyle(
                      color: _getColorForType(entity.type),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  if (isLoading)
                    const SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  else
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: onClose,
                      color: Colors.black54,
                    ),
                ],
              ),
            ),

            if (error != null)
              Container(
                padding: const EdgeInsets.all(8),
                color: Colors.red.shade50,
                child: Text(
                  error,
                  style: TextStyle(color: Colors.red.shade700),
                ),
              ),

            // Content section remains the same...
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    entity.title,
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 16),
                  _buildEntityContent(context),
                  const SizedBox(height: 16),
                  if (entity.tags.isNotEmpty) ...[
                    const Divider(),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: entity.tags
                          .map((tag) => Chip(
                                label: Text(tag),
                                backgroundColor: _getColorForType(entity.type)
                                    .withOpacity(0.1),
                                labelStyle: TextStyle(
                                    color: _getColorForType(entity.type)),
                              ))
                          .toList(),
                    ),
                  ],
                ],
              ),
            ),

            // Updated action buttons with loading state
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  // Add type-specific action buttons
                  ...switch (entity.type) {
                    EntityType.task => [
                        TextButton.icon(
                          icon: const Icon(Icons.check_circle_outline),
                          label: const Text('Mark Complete'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.completeTask(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.note => [
                        TextButton.icon(
                          icon: const Icon(Icons.edit),
                          label: const Text('Edit'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.editNote(entity.id,
                                        entity.data['content'] ?? ''),
                                  ),
                        ),
                      ],
                    EntityType.person => [
                        TextButton.icon(
                          icon: const Icon(Icons.person_add),
                          label: const Text('Add to Team'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () => actions.addPersonToTeam(entity.id),
                                  ),
                        ),
                      ],
                    EntityType.topic => [
                        TextButton.icon(
                          icon: const Icon(Icons.add_task),
                          label: const Text('Create Task'),
                          onPressed: isLoading
                              ? null
                              : () => _handleAction(
                                    context,
                                    ref,
                                    () =>
                                        actions.createTaskFromTopic(entity.id),
                                  ),
                        ),
                      ],
                  },
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Utility methods remain the same...
  Color _getColorForType(EntityType type) => switch (type) {
        EntityType.task => Colors.blue,
        EntityType.note => Colors.green,
        EntityType.person => Colors.purple,
        EntityType.topic => Colors.orange,
      };

  IconData _getIconForType(EntityType type) => switch (type) {
        EntityType.task => Icons.task_alt,
        EntityType.note => Icons.note,
        EntityType.person => Icons.person,
        EntityType.topic => Icons.topic,
      };

  // _buildEntityContent remains the same...
  Widget _buildEntityContent(BuildContext context) {
    switch (entity.type) {
      case EntityType.task:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Status: ${entity.data['status'] ?? 'New'}',
              style: Theme.of(context).textTheme.bodyLarge,
            ),
            if (entity.data['due_date'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Due: ${entity.data['due_date']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            const SizedBox(height: 16),
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        );

      case EntityType.note:
        return Text(
          entity.data['content'] ?? '',
          style: Theme.of(context).textTheme.bodyMedium,
        );

      case EntityType.person:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (entity.data['email'] != null)
              Text(
                'Email: ${entity.data['email']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            if (entity.data['role'] != null) ...[
              const SizedBox(height: 8),
              Text(
                'Role: ${entity.data['role']}',
                style: Theme.of(context).textTheme.bodyLarge,
              ),
            ],
            if (entity.data['notes'] != null) ...[
              const SizedBox(height: 16),
              Text(
                entity.data['notes'],
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ],
          ],
        );

      case EntityType.topic:
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              entity.data['description'] ?? '',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if ((entity.data['keywords'] as List?)?.isNotEmpty ?? false) ...[
              const SizedBox(height: 16),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: (entity.data['keywords'] as List)
                    .map((keyword) => Chip(
                          label: Text(keyword),
                          backgroundColor: Colors.grey.shade200,
                        ))
                    .toList(),
              ),
            ],
          ],
        );
    }
  }
}
